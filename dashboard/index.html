<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Click — Agentic Options Dashboard</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.development.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.development.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prop-types/15.8.1/prop-types.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.9/babel.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/recharts/2.10.3/Recharts.min.js"></script>
  <style>
    :root {
      --bg-primary: #0a0e17;
      --bg-card: #111827;
      --bg-card-hover: #1a2332;
      --border: #1e293b;
      --text-primary: #f1f5f9;
      --text-secondary: #94a3b8;
      --text-muted: #64748b;
      --accent-blue: #3b82f6;
      --accent-green: #10b981;
      --accent-red: #ef4444;
      --accent-amber: #f59e0b;
      --accent-purple: #8b5cf6;
      --accent-cyan: #06b6d4;
    }
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: 'SF Mono', 'Cascadia Code', 'Fira Code', 'JetBrains Mono', monospace;
      background: var(--bg-primary);
      color: var(--text-primary);
      min-height: 100vh;
    }
    .app { max-width: 1440px; margin: 0 auto; padding: 20px; }
    /* Header */
    .header {
      display: flex; justify-content: space-between; align-items: center;
      padding: 16px 0; margin-bottom: 24px; border-bottom: 1px solid var(--border);
    }
    .header h1 { font-size: 20px; font-weight: 600; letter-spacing: -0.5px; }
    .header h1 span { color: var(--accent-blue); }
    .status-badge {
      display: flex; align-items: center; gap: 8px;
      padding: 6px 14px; border-radius: 20px; font-size: 12px;
      background: rgba(16, 185, 129, 0.1); border: 1px solid rgba(16, 185, 129, 0.3);
      color: var(--accent-green);
    }
    .status-badge.offline { background: rgba(239,68,68,0.1); border-color: rgba(239,68,68,0.3); color: var(--accent-red); }
    .status-dot { width: 8px; height: 8px; border-radius: 50%; background: currentColor; animation: pulse 2s infinite; }
    @keyframes pulse { 0%,100%{opacity:1} 50%{opacity:0.5} }
    /* Cards */
    .card {
      background: var(--bg-card); border: 1px solid var(--border);
      border-radius: 12px; padding: 20px; transition: border-color 0.2s;
    }
    .card:hover { border-color: #2d3a4f; }
    .card-title {
      font-size: 11px; text-transform: uppercase; letter-spacing: 1.5px;
      color: var(--text-muted); margin-bottom: 12px; font-weight: 500;
    }
    /* Grid layouts */
    .metrics-grid { display: grid; grid-template-columns: repeat(5, 1fr); gap: 12px; margin-bottom: 20px; }
    .main-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; margin-bottom: 20px; }
    .full-width { grid-column: 1 / -1; }
    /* Metric cards */
    .metric-value { font-size: 24px; font-weight: 700; letter-spacing: -0.5px; }
    .metric-label { font-size: 11px; color: var(--text-muted); margin-top: 4px; }
    .metric-change { font-size: 12px; margin-top: 6px; }
    .positive { color: var(--accent-green); }
    .negative { color: var(--accent-red); }
    /* Positions table */
    .table { width: 100%; border-collapse: collapse; font-size: 13px; }
    .table th {
      text-align: left; padding: 10px 12px; font-size: 10px;
      text-transform: uppercase; letter-spacing: 1px; color: var(--text-muted);
      border-bottom: 1px solid var(--border); font-weight: 500;
    }
    .table td { padding: 10px 12px; border-bottom: 1px solid rgba(30,41,59,0.5); }
    .table tr:hover td { background: rgba(59,130,246,0.03); }
    .badge {
      display: inline-block; padding: 2px 8px; border-radius: 4px;
      font-size: 10px; font-weight: 600; text-transform: uppercase;
    }
    .badge-call { background: rgba(16,185,129,0.15); color: var(--accent-green); }
    .badge-put { background: rgba(239,68,68,0.15); color: var(--accent-red); }
    .badge-stock { background: rgba(59,130,246,0.15); color: var(--accent-blue); }
    /* Strategy cards */
    .strategy-card {
      background: var(--bg-card); border: 1px solid var(--border);
      border-radius: 12px; padding: 16px; margin-bottom: 12px;
      cursor: pointer; transition: all 0.2s;
    }
    .strategy-card:hover { border-color: var(--accent-blue); transform: translateY(-1px); }
    .strategy-card.selected { border-color: var(--accent-blue); background: rgba(59,130,246,0.05); }
    .strategy-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
    .strategy-name { font-size: 14px; font-weight: 600; }
    .strategy-score {
      font-size: 13px; font-weight: 700; padding: 4px 10px;
      border-radius: 6px; background: rgba(59,130,246,0.15); color: var(--accent-blue);
    }
    .strategy-details { display: grid; grid-template-columns: repeat(4, 1fr); gap: 12px; font-size: 12px; }
    .strategy-detail-label { color: var(--text-muted); font-size: 10px; text-transform: uppercase; }
    .strategy-detail-value { font-weight: 600; margin-top: 2px; }
    /* Legs */
    .legs { display: flex; gap: 8px; margin-top: 10px; flex-wrap: wrap; }
    .leg-badge {
      font-size: 11px; padding: 4px 10px; border-radius: 6px;
      background: rgba(148,163,184,0.1); border: 1px solid var(--border);
    }
    .leg-buy { border-color: rgba(16,185,129,0.3); }
    .leg-sell { border-color: rgba(239,68,68,0.3); }
    /* Factor bars */
    .factor-bar { margin-bottom: 8px; }
    .factor-bar-label { display: flex; justify-content: space-between; font-size: 11px; margin-bottom: 3px; }
    .factor-bar-track { height: 6px; background: rgba(148,163,184,0.1); border-radius: 3px; overflow: hidden; }
    .factor-bar-fill { height: 100%; border-radius: 3px; transition: width 0.5s ease; }
    /* Approve button */
    .btn-approve {
      background: var(--accent-green); color: white; border: none;
      padding: 10px 24px; border-radius: 8px; font-size: 13px;
      font-weight: 600; cursor: pointer; transition: all 0.2s;
      font-family: inherit; margin-top: 12px;
    }
    .btn-approve:hover { background: #059669; transform: translateY(-1px); }
    .btn-approve:disabled { opacity: 0.4; cursor: not-allowed; transform: none; }
    .btn-manual {
      background: transparent; color: var(--accent-cyan); border: 1px solid rgba(6,182,212,0.4);
      padding: 10px 24px; border-radius: 8px; font-size: 13px;
      font-weight: 600; cursor: pointer; transition: all 0.2s;
      font-family: inherit; margin-top: 12px;
    }
    .btn-manual:hover { background: rgba(6,182,212,0.1); border-color: var(--accent-cyan); transform: translateY(-1px); }
    .manual-panel {
      background: rgba(6,182,212,0.05); border: 1px solid rgba(6,182,212,0.2);
      border-radius: 10px; padding: 16px; margin-top: 12px; font-size: 12px;
    }
    .manual-panel-title {
      font-size: 13px; font-weight: 700; color: var(--accent-cyan);
      margin-bottom: 12px; display: flex; align-items: center; gap: 8px;
    }
    .manual-leg {
      background: rgba(0,0,0,0.2); border-radius: 8px; padding: 12px;
      margin-bottom: 8px; border-left: 3px solid;
    }
    .manual-leg-buy { border-left-color: var(--accent-green); }
    .manual-leg-sell { border-left-color: var(--accent-red); }
    .manual-leg-title {
      font-weight: 700; font-size: 13px; margin-bottom: 8px;
      display: flex; align-items: center; gap: 6px;
    }
    .manual-field {
      display: flex; justify-content: space-between; padding: 3px 0;
      border-bottom: 1px solid rgba(30,41,59,0.3);
    }
    .manual-field-label { color: var(--text-muted); }
    .manual-field-value { font-weight: 600; color: var(--text-primary); font-family: monospace; }
    .manual-copy-btn {
      background: rgba(6,182,212,0.12); border: 1px solid rgba(6,182,212,0.3);
      color: var(--accent-cyan); padding: 4px 10px; border-radius: 6px;
      cursor: pointer; font-size: 10px; font-weight: 600; font-family: inherit;
      margin-left: 8px;
    }
    .manual-copy-btn:hover { background: rgba(6,182,212,0.25); }
    /* Greeks display */
    .greeks-row { display: flex; gap: 16px; flex-wrap: wrap; }
    .greek-item { text-align: center; min-width: 80px; }
    .greek-symbol { font-size: 18px; font-weight: 700; color: var(--accent-cyan); }
    .greek-value { font-size: 16px; font-weight: 600; margin-top: 4px; }
    .greek-name { font-size: 10px; color: var(--text-muted); text-transform: uppercase; margin-top: 2px; }
    /* Stress test bars */
    .stress-bar-container { margin-bottom: 10px; }
    .stress-label { display: flex; justify-content: space-between; font-size: 12px; margin-bottom: 4px; }
    .stress-bar {
      height: 24px; border-radius: 4px; display: flex; align-items: center;
      padding: 0 8px; font-size: 11px; font-weight: 600; min-width: 2px;
      transition: width 0.5s ease;
    }
    /* Tabs */
    .tabs { display: flex; gap: 0; margin-bottom: 16px; border-bottom: 1px solid var(--border); }
    .tab {
      padding: 8px 16px; font-size: 12px; cursor: pointer;
      color: var(--text-muted); border-bottom: 2px solid transparent;
      transition: all 0.2s; background: none; border-top: none;
      border-left: none; border-right: none; font-family: inherit;
    }
    .tab:hover { color: var(--text-secondary); }
    .tab.active { color: var(--accent-blue); border-bottom-color: var(--accent-blue); }
    /* Symbol input */
    .symbol-input-group { display: flex; gap: 8px; margin-bottom: 16px; }
    .symbol-input {
      background: var(--bg-card); border: 1px solid var(--border);
      color: var(--text-primary); padding: 8px 14px; border-radius: 8px;
      font-family: inherit; font-size: 14px; width: 140px;
      text-transform: uppercase; outline: none;
    }
    .symbol-input:focus { border-color: var(--accent-blue); }
    .btn-analyze {
      background: var(--accent-blue); color: white; border: none;
      padding: 8px 20px; border-radius: 8px; font-size: 13px;
      font-weight: 600; cursor: pointer; font-family: inherit;
    }
    .btn-analyze:hover { background: #2563eb; }
    .btn-analyze:disabled { opacity: 0.5; cursor: not-allowed; }
    /* Goals panel */
    .goals-panel {
      background: var(--bg-card); border: 1px solid var(--border);
      border-radius: 12px; padding: 16px; margin-bottom: 16px;
    }
    .goals-toggle {
      display: flex; justify-content: space-between; align-items: center;
      cursor: pointer;
    }
    .goals-toggle-title {
      font-size: 13px; font-weight: 700; color: var(--accent-purple);
      display: flex; align-items: center; gap: 8px;
    }
    .goals-toggle-arrow {
      color: var(--text-muted); font-size: 12px; transition: transform 0.2s;
    }
    .goals-grid {
      display: grid; grid-template-columns: 1fr 1fr; gap: 14px;
      margin-top: 14px;
    }
    .goal-field label {
      display: block; font-size: 11px; color: var(--text-muted);
      text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 4px;
    }
    .goal-field input, .goal-field select {
      background: rgba(0,0,0,0.2); border: 1px solid var(--border);
      color: var(--text-primary); padding: 7px 10px; border-radius: 6px;
      font-family: inherit; font-size: 13px; width: 100%; outline: none;
    }
    .goal-field input:focus, .goal-field select:focus { border-color: var(--accent-purple); }
    .goal-strat-chips {
      display: flex; flex-wrap: wrap; gap: 6px; margin-top: 6px;
    }
    .goal-chip {
      padding: 4px 10px; border-radius: 6px; font-size: 11px;
      font-weight: 600; cursor: pointer; border: 1px solid var(--border);
      background: transparent; color: var(--text-muted); transition: all 0.15s;
      font-family: inherit;
    }
    .goal-chip.active {
      background: rgba(139,92,246,0.15); border-color: rgba(139,92,246,0.4);
      color: var(--accent-purple);
    }
    .goal-chip:hover { border-color: var(--accent-purple); }
    .goal-progress-bar {
      background: rgba(0,0,0,0.2); border-radius: 6px; height: 8px;
      overflow: hidden; margin-top: 4px;
    }
    .goal-progress-fill {
      height: 100%; border-radius: 6px; transition: width 0.4s ease;
      background: linear-gradient(90deg, var(--accent-purple), var(--accent-cyan));
    }
    .goal-summary {
      background: rgba(139,92,246,0.06); border: 1px solid rgba(139,92,246,0.15);
      border-radius: 10px; padding: 14px; margin-bottom: 14px;
      display: flex; gap: 20px; align-items: center; flex-wrap: wrap;
    }
    .goal-summary-item {
      display: flex; flex-direction: column; gap: 2px;
    }
    .goal-summary-label { font-size: 10px; color: var(--text-muted); text-transform: uppercase; }
    .goal-summary-value { font-size: 18px; font-weight: 700; }
    /* Loading */
    .loading { text-align: center; padding: 40px; color: var(--text-muted); }
    .spinner { display: inline-block; width: 24px; height: 24px; border: 2px solid var(--border);
      border-top-color: var(--accent-blue); border-radius: 50%;
      animation: spin 0.8s linear infinite; margin-bottom: 8px; }
    @keyframes spin { to { transform: rotate(360deg); } }
    /* Risk warning */
    .risk-warning {
      background: rgba(239,68,68,0.08); border: 1px solid rgba(239,68,68,0.2);
      border-radius: 8px; padding: 12px 16px; font-size: 12px;
      color: var(--accent-red); margin-top: 10px;
    }
    /* Account Banner */
    .account-banner {
      background: linear-gradient(135deg, rgba(59,130,246,0.08) 0%, rgba(16,185,129,0.08) 100%);
      border: 1px solid rgba(59,130,246,0.2);
      border-radius: 16px; padding: 24px 32px; margin-bottom: 20px;
      display: flex; justify-content: space-between; align-items: center;
      flex-wrap: wrap; gap: 20px;
    }
    .account-banner-main {
      display: flex; flex-direction: column; gap: 4px;
    }
    .account-banner-label {
      font-size: 11px; text-transform: uppercase; letter-spacing: 1.5px;
      color: var(--text-muted); font-weight: 500;
    }
    .account-banner-value {
      font-size: 36px; font-weight: 800; letter-spacing: -1px;
      background: linear-gradient(135deg, #3b82f6, #10b981);
      -webkit-background-clip: text; -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    .account-banner-sub {
      font-size: 12px; color: var(--text-secondary); margin-top: 2px;
    }
    .account-banner-stats {
      display: flex; gap: 32px; flex-wrap: wrap;
    }
    .account-stat { text-align: center; }
    .account-stat-value { font-size: 20px; font-weight: 700; }
    .account-stat-label { font-size: 10px; color: var(--text-muted); text-transform: uppercase; letter-spacing: 1px; margin-top: 2px; }
    .data-source-badge {
      display: inline-flex; align-items: center; gap: 6px;
      padding: 4px 10px; border-radius: 12px; font-size: 10px; font-weight: 600;
      text-transform: uppercase; letter-spacing: 0.5px;
    }
    .data-source-live {
      background: rgba(16,185,129,0.12); border: 1px solid rgba(16,185,129,0.3);
      color: var(--accent-green);
    }
    .data-source-demo {
      background: rgba(245,158,11,0.12); border: 1px solid rgba(245,158,11,0.3);
      color: var(--accent-amber);
    }
    /* Capital usage bar on strategy cards */
    .capital-bar-wrapper { margin-top: 10px; }
    .capital-bar-label {
      display: flex; justify-content: space-between; font-size: 10px;
      color: var(--text-muted); margin-bottom: 3px; text-transform: uppercase;
    }
    .capital-bar-track {
      height: 8px; background: rgba(148,163,184,0.1); border-radius: 4px;
      overflow: hidden;
    }
    .capital-bar-fill {
      height: 100%; border-radius: 4px; transition: width 0.5s ease;
    }
    /* Analysis account info */
    .analysis-account-bar {
      background: var(--bg-card); border: 1px solid var(--border);
      border-radius: 10px; padding: 12px 20px; margin-bottom: 16px;
      display: flex; align-items: center; gap: 24px; font-size: 13px;
      flex-wrap: wrap;
    }
    .analysis-account-item { display: flex; align-items: center; gap: 6px; }
    .analysis-account-dot { width: 8px; height: 8px; border-radius: 50%; }
    /* Info tooltip */
    .info-icon {
      display: inline-flex; align-items: center; justify-content: center;
      width: 14px; height: 14px; border-radius: 50%; font-size: 9px; font-weight: 700;
      background: rgba(148,163,184,0.2); color: var(--text-muted);
      cursor: help; position: relative; margin-left: 4px; vertical-align: middle;
      font-style: normal;
    }
    .info-icon .info-tooltip {
      display: none; position: absolute; bottom: calc(100% + 8px); left: 50%;
      transform: translateX(-50%); width: 260px; padding: 12px 14px;
      background: #1e293b; border: 1px solid var(--border); border-radius: 8px;
      font-size: 11px; font-weight: 400; color: var(--text-secondary);
      line-height: 1.5; z-index: 100; box-shadow: 0 8px 24px rgba(0,0,0,0.5);
      text-transform: none; letter-spacing: 0; white-space: normal;
    }
    .info-icon .info-tooltip::after {
      content: ""; position: absolute; top: 100%; left: 50%; transform: translateX(-50%);
      border: 6px solid transparent; border-top-color: #1e293b;
    }
    .info-icon:hover .info-tooltip { display: block; }
    /* Toast notifications */
    .toast-container {
      position: fixed; top: 20px; right: 20px; z-index: 1000;
      display: flex; flex-direction: column; gap: 8px; max-width: 420px;
    }
    .toast {
      padding: 14px 20px; border-radius: 10px; font-size: 13px;
      display: flex; align-items: flex-start; gap: 10px;
      animation: slideIn 0.3s ease, fadeOut 0.3s ease 4.7s forwards;
      box-shadow: 0 8px 24px rgba(0,0,0,0.4);
    }
    .toast-success {
      background: rgba(16,185,129,0.15); border: 1px solid rgba(16,185,129,0.4);
      color: var(--accent-green);
    }
    .toast-error {
      background: rgba(239,68,68,0.15); border: 1px solid rgba(239,68,68,0.4);
      color: var(--accent-red);
    }
    .toast-info {
      background: rgba(59,130,246,0.15); border: 1px solid rgba(59,130,246,0.4);
      color: var(--accent-blue);
    }
    .toast-icon { font-size: 18px; flex-shrink: 0; }
    .toast-body { flex: 1; }
    .toast-title { font-weight: 700; margin-bottom: 2px; }
    .toast-msg { font-size: 12px; opacity: 0.85; }
    @keyframes slideIn { from { transform: translateX(100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
    @keyframes fadeOut { to { opacity: 0; transform: translateY(-10px); } }
    /* Orders table */
    .order-status {
      display: inline-flex; align-items: center; gap: 6px;
      padding: 3px 10px; border-radius: 6px; font-size: 11px; font-weight: 600;
    }
    .order-approved { background: rgba(16,185,129,0.15); color: var(--accent-green); }
    .order-pending { background: rgba(245,158,11,0.15); color: var(--accent-amber); }
    .order-failed { background: rgba(239,68,68,0.15); color: var(--accent-red); }
    .order-error { background: rgba(239,68,68,0.15); color: var(--accent-red); }
    .order-submitted { background: rgba(59,130,246,0.15); color: var(--accent-blue); }
    .order-filled { background: rgba(16,185,129,0.15); color: var(--accent-green); }
    .order-partial_fill { background: rgba(6,182,212,0.15); color: var(--accent-cyan); }
    .order-cancelled { background: rgba(148,163,184,0.15); color: var(--text-muted); }
    .order-rejected { background: rgba(239,68,68,0.15); color: var(--accent-red); }
    .order-local_only { background: rgba(245,158,11,0.15); color: var(--accent-amber); }
    .ibkr-ids { font-size: 10px; color: var(--accent-cyan); margin-top: 2px; font-family: monospace; }
    /* Error detail panel */
    .error-detail-panel {
      background: rgba(239,68,68,0.06); border: 1px solid rgba(239,68,68,0.2);
      border-radius: 10px; padding: 16px; margin-bottom: 12px;
    }
    .error-detail-header {
      display: flex; align-items: center; gap: 8px; margin-bottom: 12px;
      font-weight: 700; font-size: 13px; color: var(--accent-red);
    }
    .error-detail-order {
      background: rgba(0,0,0,0.2); border-radius: 8px; padding: 12px; margin-bottom: 10px;
    }
    .error-detail-code {
      font-family: monospace; font-size: 12px; font-weight: 700;
      color: var(--accent-amber); margin-bottom: 4px;
    }
    .error-detail-msg {
      font-size: 12px; color: var(--accent-red); margin-bottom: 8px;
    }
    .error-detail-explain {
      font-size: 12px; color: var(--text-secondary); line-height: 1.6;
      background: rgba(0,0,0,0.15); border-radius: 6px; padding: 10px;
    }
    .error-detail-explain b { color: var(--text-primary); }
    .error-detail-fix {
      margin-top: 8px; font-size: 11px; color: var(--accent-cyan);
      padding: 6px 10px; background: rgba(6,182,212,0.08);
      border-radius: 6px; border-left: 3px solid var(--accent-cyan);
    }
    .orders-empty {
      text-align: center; padding: 60px 20px; color: var(--text-muted);
    }
    .orders-empty-icon { font-size: 48px; margin-bottom: 12px; opacity: 0.3; }
    .orders-empty-text { font-size: 14px; margin-bottom: 4px; }
    .orders-empty-sub { font-size: 12px; }
    /* Verify panel */
    .verify-bar {
      display: flex; align-items: center; gap: 12px; margin-bottom: 16px;
    }
    .verify-btn {
      background: rgba(6,182,212,0.12); border: 1px solid rgba(6,182,212,0.3);
      color: var(--accent-cyan); padding: 7px 16px; border-radius: 8px;
      cursor: pointer; font-size: 12px; font-weight: 600; font-family: inherit;
      transition: all 0.2s;
    }
    .verify-btn:hover { background: rgba(6,182,212,0.22); border-color: var(--accent-cyan); }
    .verify-btn:disabled { opacity: 0.5; cursor: not-allowed; }
    .verify-result {
      background: rgba(6,182,212,0.05); border: 1px solid rgba(6,182,212,0.15);
      border-radius: 10px; padding: 14px; margin-bottom: 16px; font-size: 12px;
    }
    .verify-row {
      display: flex; align-items: center; gap: 8px; padding: 4px 0;
    }
    .verify-icon-ok { color: var(--accent-green); }
    .verify-icon-fail { color: var(--accent-red); }
    .verify-icon-warn { color: var(--accent-amber); }
    .verify-summary {
      display: flex; gap: 20px; margin-bottom: 10px; font-size: 13px; font-weight: 600;
    }
    .tab-badge {
      display: inline-flex; align-items: center; justify-content: center;
      min-width: 18px; height: 18px; padding: 0 5px;
      border-radius: 9px; font-size: 10px; font-weight: 700;
      margin-left: 6px;
    }
    .tab-badge-active { background: var(--accent-blue); color: white; }
    .tab-badge-idle { background: rgba(148,163,184,0.2); color: var(--text-muted); }
    /* Watchlist symbols */
    .watchlist-chips {
      display: flex; flex-wrap: wrap; gap: 6px; margin-top: 6px;
    }
    .watchlist-chip {
      display: inline-flex; align-items: center; gap: 4px;
      padding: 4px 10px; border-radius: 6px; font-size: 12px;
      font-weight: 700; font-family: inherit;
      background: rgba(59,130,246,0.12); border: 1px solid rgba(59,130,246,0.3);
      color: var(--accent-blue);
    }
    .watchlist-chip-remove {
      background: none; border: none; color: var(--text-muted); cursor: pointer;
      font-size: 14px; line-height: 1; padding: 0 0 0 2px; font-family: inherit;
    }
    .watchlist-chip-remove:hover { color: var(--accent-red); }
    .watchlist-add-row { display: flex; gap: 6px; margin-top: 8px; }
    .watchlist-add-input {
      background: rgba(0,0,0,0.2); border: 1px solid var(--border);
      color: var(--text-primary); padding: 5px 8px; border-radius: 6px;
      font-family: inherit; font-size: 12px; width: 100px;
      text-transform: uppercase; outline: none;
    }
    .watchlist-add-input:focus { border-color: var(--accent-blue); }
    .watchlist-add-btn {
      background: rgba(59,130,246,0.12); border: 1px solid rgba(59,130,246,0.3);
      color: var(--accent-blue); padding: 5px 10px; border-radius: 6px;
      font-size: 11px; font-weight: 600; cursor: pointer; font-family: inherit;
    }
    .watchlist-add-btn:hover { background: rgba(59,130,246,0.25); }
    /* Scan All button */
    .btn-scan-all {
      background: linear-gradient(135deg, var(--accent-purple), var(--accent-blue));
      color: white; border: none;
      padding: 10px 28px; border-radius: 8px; font-size: 14px;
      font-weight: 700; cursor: pointer; font-family: inherit;
      transition: all 0.2s; margin-bottom: 16px;
      display: flex; align-items: center; gap: 8px;
    }
    .btn-scan-all:hover { transform: translateY(-1px); box-shadow: 0 4px 16px rgba(139,92,246,0.3); }
    .btn-scan-all:disabled { opacity: 0.5; cursor: not-allowed; transform: none; box-shadow: none; }
    /* Portfolio Plan */
    .plan-container {
      background: var(--bg-card); border: 1px solid var(--border);
      border-radius: 14px; padding: 24px; margin-bottom: 16px;
    }
    .plan-header {
      display: flex; justify-content: space-between; align-items: center;
      margin-bottom: 20px;
    }
    .plan-title {
      font-size: 16px; font-weight: 700; color: var(--accent-purple);
      display: flex; align-items: center; gap: 8px;
    }
    .plan-target-badge {
      font-size: 13px; font-weight: 700; padding: 4px 12px;
      border-radius: 8px;
      background: rgba(139,92,246,0.15); border: 1px solid rgba(139,92,246,0.3);
      color: var(--accent-purple);
    }
    .plan-summary-row {
      display: grid; grid-template-columns: repeat(5, 1fr); gap: 16px;
      margin-bottom: 20px; padding: 16px;
      background: rgba(0,0,0,0.15); border-radius: 10px;
    }
    .plan-summary-item { text-align: center; }
    .plan-summary-value { font-size: 22px; font-weight: 800; }
    .plan-summary-label { font-size: 10px; color: var(--text-muted); text-transform: uppercase; margin-top: 3px; }
    .plan-progress-section { margin-bottom: 20px; }
    .plan-progress-header {
      display: flex; justify-content: space-between; align-items: center;
      margin-bottom: 8px; font-size: 13px;
    }
    .plan-progress-bar {
      background: rgba(0,0,0,0.25); border-radius: 8px; height: 14px;
      overflow: hidden; position: relative;
    }
    .plan-progress-fill {
      height: 100%; border-radius: 8px; transition: width 0.6s ease;
      position: relative;
    }
    .plan-progress-fill::after {
      content: ""; position: absolute; right: 0; top: 0; bottom: 0; width: 2px;
      background: rgba(255,255,255,0.6);
    }
    .plan-strategies-list { display: flex; flex-direction: column; gap: 10px; }
    .plan-strat-row {
      display: grid; grid-template-columns: 36px 1fr 120px 100px 100px 90px 60px;
      gap: 12px; align-items: center;
      background: rgba(0,0,0,0.1); border-radius: 10px; padding: 12px 16px;
      border: 1px solid var(--border); transition: border-color 0.2s;
    }
    .plan-strat-row:hover { border-color: rgba(139,92,246,0.3); }
    .plan-strat-num {
      width: 28px; height: 28px; border-radius: 50%;
      display: flex; align-items: center; justify-content: center;
      font-size: 12px; font-weight: 800;
      background: rgba(139,92,246,0.15); color: var(--accent-purple);
    }
    .plan-strat-name { font-weight: 600; font-size: 13px; }
    .plan-strat-symbol {
      font-size: 11px; color: var(--accent-blue); font-weight: 700;
      margin-top: 2px;
    }
    .plan-strat-profit { font-weight: 700; color: var(--accent-green); font-size: 14px; }
    .plan-strat-risk { font-weight: 600; font-size: 12px; }
    .plan-strat-capital { font-size: 12px; color: var(--text-secondary); }
    .plan-strat-dte { font-size: 12px; color: var(--text-muted); }
    .plan-strat-pct {
      font-size: 12px; font-weight: 700; padding: 2px 6px; border-radius: 4px;
      text-align: center;
    }
    .plan-allocation-bar {
      height: 4px; background: rgba(148,163,184,0.1); border-radius: 2px;
      overflow: hidden; margin-top: 4px;
    }
    .plan-allocation-fill {
      height: 100%; border-radius: 2px; transition: width 0.5s;
    }
    .plan-symbol-section {
      margin-bottom: 8px;
    }
    .plan-symbol-header {
      font-size: 11px; font-weight: 700; color: var(--accent-blue);
      text-transform: uppercase; letter-spacing: 1px;
      margin-bottom: 6px; padding: 4px 8px;
      background: rgba(59,130,246,0.06); border-radius: 6px;
      display: flex; justify-content: space-between; align-items: center;
    }
    /* Position close panel */
    .pos-row-clickable { cursor: pointer; }
    .pos-row-clickable:hover td { background: rgba(139,92,246,0.04) !important; }
    .pos-row-expanded td { background: rgba(139,92,246,0.03) !important; border-bottom: none !important; }
    .pos-close-panel {
      background: rgba(0,0,0,0.12); border: 1px solid var(--border);
      border-radius: 0 0 10px 10px; padding: 16px; margin: 0 0 8px 0;
    }
    .pos-close-header {
      display: flex; justify-content: space-between; align-items: center;
      margin-bottom: 12px;
    }
    .pos-close-title {
      font-size: 13px; font-weight: 700; display: flex; align-items: center; gap: 8px;
    }
    .pos-close-pnl-badge {
      padding: 4px 12px; border-radius: 8px; font-size: 14px; font-weight: 800;
    }
    .pos-close-grid {
      display: grid; grid-template-columns: repeat(4, 1fr); gap: 14px;
      margin-bottom: 14px;
    }
    .pos-close-stat { text-align: center; }
    .pos-close-stat-value { font-size: 18px; font-weight: 700; }
    .pos-close-stat-label { font-size: 10px; color: var(--text-muted); text-transform: uppercase; margin-top: 2px; }
    .pos-close-how {
      background: rgba(0,0,0,0.15); border-radius: 8px; padding: 14px;
      margin-bottom: 12px;
    }
    .pos-close-how-title {
      font-size: 12px; font-weight: 700; color: var(--accent-cyan);
      margin-bottom: 8px; display: flex; align-items: center; gap: 6px;
    }
    .pos-close-step {
      display: flex; gap: 10px; padding: 6px 0;
      border-bottom: 1px solid rgba(30,41,59,0.3); font-size: 12px;
    }
    .pos-close-step:last-child { border-bottom: none; }
    .pos-close-step-num {
      width: 22px; height: 22px; border-radius: 50%; flex-shrink: 0;
      display: flex; align-items: center; justify-content: center;
      font-size: 11px; font-weight: 800;
      background: rgba(6,182,212,0.15); color: var(--accent-cyan);
    }
    .pos-close-actions {
      display: flex; gap: 10px; align-items: center; margin-top: 4px;
    }
    .pos-close-note {
      font-size: 11px; color: var(--text-muted); line-height: 1.5;
      padding: 10px; background: rgba(245,158,11,0.06);
      border: 1px solid rgba(245,158,11,0.15); border-radius: 8px;
    }
    .pos-close-recommendation {
      display: flex; align-items: center; gap: 8px; padding: 10px 14px;
      border-radius: 8px; font-size: 12px; font-weight: 600; margin-bottom: 12px;
    }
    .pos-rec-profit {
      background: rgba(16,185,129,0.1); border: 1px solid rgba(16,185,129,0.25);
      color: var(--accent-green);
    }
    .pos-rec-loss {
      background: rgba(239,68,68,0.1); border: 1px solid rgba(239,68,68,0.25);
      color: var(--accent-red);
    }
    .pos-rec-neutral {
      background: rgba(245,158,11,0.1); border: 1px solid rgba(245,158,11,0.25);
      color: var(--accent-amber);
    }
    /* Verdict banner */
    .pos-verdict {
      border-radius: 10px; padding: 16px; margin-bottom: 14px;
      display: flex; align-items: center; gap: 14px;
    }
    .pos-verdict-icon { font-size: 32px; }
    .pos-verdict-text { flex: 1; }
    .pos-verdict-title { font-size: 16px; font-weight: 800; margin-bottom: 4px; }
    .pos-verdict-sub { font-size: 12px; opacity: 0.85; line-height: 1.4; }
    .pos-verdict-profit {
      background: linear-gradient(135deg, rgba(16,185,129,0.12), rgba(16,185,129,0.06));
      border: 1px solid rgba(16,185,129,0.3); color: var(--accent-green);
    }
    .pos-verdict-loss {
      background: linear-gradient(135deg, rgba(239,68,68,0.12), rgba(239,68,68,0.06));
      border: 1px solid rgba(239,68,68,0.3); color: var(--accent-red);
    }
    .pos-verdict-breakeven {
      background: linear-gradient(135deg, rgba(245,158,11,0.12), rgba(245,158,11,0.06));
      border: 1px solid rgba(245,158,11,0.3); color: var(--accent-amber);
    }
    /* Recovery strategies */
    .pos-recovery {
      background: rgba(59,130,246,0.05); border: 1px solid rgba(59,130,246,0.2);
      border-radius: 10px; padding: 16px; margin-bottom: 14px;
    }
    .pos-recovery-title {
      font-size: 13px; font-weight: 700; color: var(--accent-blue);
      margin-bottom: 12px; display: flex; align-items: center; gap: 8px;
    }
    .pos-recovery-option {
      background: rgba(0,0,0,0.15); border-radius: 8px; padding: 12px;
      margin-bottom: 8px; border-left: 3px solid var(--accent-blue);
    }
    .pos-recovery-option:last-child { margin-bottom: 0; }
    .pos-recovery-option-header {
      display: flex; justify-content: space-between; align-items: center;
      margin-bottom: 6px;
    }
    .pos-recovery-option-name {
      font-size: 13px; font-weight: 700; color: var(--text-primary);
      display: flex; align-items: center; gap: 6px;
    }
    .pos-recovery-option-tag {
      font-size: 10px; font-weight: 700; padding: 2px 8px; border-radius: 4px;
    }
    .pos-recovery-option-desc {
      font-size: 12px; color: var(--text-secondary); line-height: 1.5;
    }
    .pos-recovery-option-steps {
      margin-top: 8px; padding-top: 8px; border-top: 1px solid rgba(30,41,59,0.3);
    }
    .pos-recovery-step {
      font-size: 11px; color: var(--text-secondary); padding: 2px 0;
      display: flex; gap: 6px;
    }
    .pos-recovery-step b { color: var(--text-primary); }
    .pos-recovery-step-bullet {
      color: var(--accent-cyan); font-weight: 800; flex-shrink: 0;
    }
    /* Strategy group rows */
    .strategy-group-row td {
      background: rgba(139,92,246,0.06) !important;
      border-bottom: 2px solid rgba(139,92,246,0.25);
      padding: 10px 12px;
    }
    .strategy-group-label {
      display: flex; align-items: center; gap: 8px;
    }
    .strategy-group-badge {
      display: inline-flex; align-items: center; gap: 6px;
      padding: 4px 12px; border-radius: 6px; font-size: 12px; font-weight: 700;
      background: rgba(139,92,246,0.15); color: var(--accent-purple);
    }
    .strategy-group-legs {
      display: flex; gap: 6px; flex-wrap: wrap;
    }
    .strategy-group-leg {
      font-size: 10px; padding: 2px 8px; border-radius: 4px;
      background: rgba(255,255,255,0.06); color: var(--text-secondary);
    }
    .strategy-group-clickable {
      cursor: pointer; transition: background 0.15s;
    }
    .strategy-group-clickable:hover td {
      background: rgba(139,92,246,0.1) !important;
    }
    .strategy-close-panel {
      padding: 20px; background: linear-gradient(135deg, rgba(139,92,246,0.04), rgba(59,130,246,0.04));
    }
    .strategy-close-verdict {
      border-radius: 10px; padding: 16px; margin-bottom: 14px;
      display: flex; align-items: center; gap: 14px;
    }
    .strategy-close-legs-table {
      width: 100%; border-collapse: collapse; font-size: 12px; margin-bottom: 14px;
    }
    .strategy-close-legs-table th {
      text-align: left; padding: 6px 10px; font-size: 10px; text-transform: uppercase;
      letter-spacing: 0.8px; color: var(--text-muted); border-bottom: 1px solid var(--border); font-weight: 500;
    }
    .strategy-close-legs-table td {
      padding: 6px 10px; border-bottom: 1px solid rgba(30,41,59,0.3);
    }
    .strategy-close-summary {
      display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px;
      background: rgba(0,0,0,0.15); border-radius: 8px; padding: 14px; margin-bottom: 14px;
    }
    .strategy-close-summary-stat { text-align: center; }
    .strategy-close-summary-value { font-size: 18px; font-weight: 700; }
    .strategy-close-summary-label { font-size: 10px; color: var(--text-muted); text-transform: uppercase; margin-top: 2px; }
    .strategy-close-how-panel {
      background: rgba(0,0,0,0.1); border: 1px solid var(--border);
      border-radius: 8px; padding: 14px; margin-bottom: 12px;
    }
    .strategy-close-how-title {
      font-size: 13px; font-weight: 700; color: var(--accent-cyan);
      margin-bottom: 8px; display: flex; align-items: center; gap: 6px;
    }
    .exp-badge {
      display: inline-block; padding: 1px 6px; border-radius: 4px;
      font-size: 10px; font-weight: 600;
    }
    .exp-safe { background: rgba(16,185,129,0.12); color: var(--accent-green); }
    .exp-warning { background: rgba(245,158,11,0.12); color: var(--accent-amber); }
    .exp-danger { background: rgba(239,68,68,0.12); color: var(--accent-red); }
    /* Responsive */
    @media (max-width: 1024px) {
      .metrics-grid { grid-template-columns: repeat(3, 1fr); }
      .main-grid { grid-template-columns: 1fr; }
      .account-banner { flex-direction: column; align-items: flex-start; }
    }
    @media (max-width: 640px) {
      .metrics-grid { grid-template-columns: repeat(2, 1fr); }
      .strategy-details { grid-template-columns: repeat(2, 1fr); }
      .account-banner-value { font-size: 28px; }
      .account-banner-stats { gap: 16px; }
      .plan-summary-row { grid-template-columns: repeat(2, 1fr); }
      .plan-strat-row { grid-template-columns: 1fr; font-size: 12px; }
    }
  </style>
</head>
<body>
<div id="root"></div>
<script type="text/babel">
const { useState, useEffect, useCallback, useMemo, useRef } = React;
const RC = window.Recharts || {};
const { AreaChart, Area, BarChart, Bar, LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer, ReferenceLine, ReferenceDot } = RC;

const API = window.location.origin + "/api";

// ═══════════════════════════════════════════════════════════
//  UTILITIES
// ═══════════════════════════════════════════════════════════

const fmt = {
  usd: (v) => v == null ? "—" : "$" + Math.abs(v).toLocaleString("en-US", { minimumFractionDigits: 2, maximumFractionDigits: 2 }),
  pct: (v) => v == null ? "—" : (v >= 0 ? "+" : "") + v.toFixed(2) + "%",
  num: (v, d = 2) => v == null ? "—" : v.toLocaleString("en-US", { minimumFractionDigits: d, maximumFractionDigits: d }),
  sign: (v) => v == null ? "—" : (v >= 0 ? "+" : "") + v.toLocaleString("en-US", { minimumFractionDigits: 2, maximumFractionDigits: 2 }),
};

// IBKR tick size rounding — options <$3.00 trade in $0.05 (penny-pilot: $0.01), >= $3.00 in $0.10
const PENNY_PILOT = new Set(["AAPL","AMD","AMZN","BAC","C","CSCO","DIS","EEM","EWZ","F","GE","GILD","GLD","GM","GOOGL","GOOG","IWM","JPM","META","MSFT","MU","NFLX","NVDA","PFE","QQQ","SNAP","SPY","SQ","T","TGT","TSLA","UBER","VXX","WFC","XLF"]);
function roundTick(price, underlying) {
  if (!price || price <= 0) return 0;
  const tick = price >= 3.0 ? 0.10 : (underlying && PENNY_PILOT.has(underlying.toUpperCase()) ? 0.01 : 0.05);
  return Math.round(Math.round(price / tick) * tick * 100) / 100;
}

// Parse date from various formats: YYYYMMDD string, ISO string, Date object, or epoch
function parseExpDate(v) {
  if (!v) return null;
  const s = String(v).trim();
  if (/^\d{8}$/.test(s)) {
    // YYYYMMDD → local date (no UTC shift)
    return new Date(parseInt(s.slice(0,4)), parseInt(s.slice(4,6))-1, parseInt(s.slice(6,8)));
  }
  const d = new Date(v);
  return isNaN(d.getTime()) ? null : d;
}

async function apiFetch(endpoint) {
  try {
    const res = await fetch(API + endpoint);
    const json = await res.json();
    return json.success ? json.data : null;
  } catch { return null; }
}

async function apiRawFetch(endpoint, opts) {
  const res = await fetch(API + endpoint, opts);
  const ct = res.headers.get("content-type") || "";
  if (!ct.includes("application/json")) {
    throw new Error(`Server returned ${res.status} — restart the server (npm run dashboard) and try again`);
  }
  return res.json();
}

// ── Human-readable position name formatting ──
const MONTH_SHORT = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];
function formatPositionName(p) {
  const type = p.contract.type;
  const underlying = p.contract.underlying || p.contract.symbol || "?";
  const isOption = type === "call" || type === "put";
  if (!isOption) return underlying;
  const strike = p.contract.strike ? `$${p.contract.strike}` : "";
  const exp = parseExpDate(p.contract.expiration);
  const expStr = exp ? `${MONTH_SHORT[exp.getMonth()]} ${exp.getDate()}` : "";
  const side = p.quantity < 0 ? "Short" : "Long";
  return `${underlying} ${side} ${type === "call" ? "Call" : "Put"} ${strike} ${expStr}`.trim();
}

// ── Submit close order to server ──
async function submitCloseOrder(legs) {
  const res = await fetch(API + "/close", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ legs }),
  });
  return res.json();
}

// ── Estimate rolled option price ──
// Uses sqrt(time) relationship for time value + delta-based strike adjustment
// delta: the option's Greek delta (absolute value used). If unavailable, 0.35 is assumed.
function estimateRolledPrice(currentPrice, currentDTE, newDTE, strikeDiff, delta) {
  if (!currentPrice || currentPrice <= 0) return 0;
  const safeDTE = Math.max(currentDTE || 1, 1);
  // Time value scales approximately with sqrt(DTE)
  const timeScaled = currentPrice * Math.sqrt(Math.max(newDTE, 1) / safeDTE);
  // Strike shift: moving further OTM reduces value by approx. delta × strikeDiff
  if (strikeDiff !== 0) {
    const effectiveDelta = delta ? Math.abs(delta) : 0.35;
    return Math.max(0.01, timeScaled - effectiveDelta * Math.abs(strikeDiff));
  }
  return timeScaled;
}

// ── Format signed USD: "+$3.50" or "-$1.20" ──
function fmtSignUsd(v) {
  if (v == null) return "—";
  const prefix = v >= 0 ? "+" : "-";
  return prefix + "$" + Math.abs(v).toLocaleString("en-US", { minimumFractionDigits: 2, maximumFractionDigits: 2 });
}

// ── Find next standard monthly expiration (3rd Friday of month) ──
// Options standard monthly expirations are the 3rd Friday of each month.
// Returns the next monthly expiration that is:
//   1) at least minDaysOut from today, AND
//   2) strictly AFTER afterDate (the current position's expiration), if provided.
// This prevents a "roll" to the same expiration date.
function nextMonthlyExpiration(minDaysOut, afterDate) {
  const now = new Date();
  const target = new Date(now);
  target.setDate(target.getDate() + (minDaysOut || 21));

  // Normalize afterDate for comparison (midnight local)
  let afterTime = 0;
  if (afterDate instanceof Date && !isNaN(afterDate.getTime())) {
    const ad = new Date(afterDate.getFullYear(), afterDate.getMonth(), afterDate.getDate());
    afterTime = ad.getTime();
  }

  // Start searching from the target month, up to 12 months out
  for (let m = 0; m < 12; m++) {
    const year = target.getFullYear();
    const month = target.getMonth() + m;
    const adjYear = year + Math.floor(month / 12);
    const adjMonth = month % 12;

    // Find the 3rd Friday: first day of month, find first Friday, add 14 days
    const firstDay = new Date(adjYear, adjMonth, 1);
    const firstFriday = 1 + ((5 - firstDay.getDay() + 7) % 7); // day-of-month of 1st Friday
    const thirdFriday = new Date(adjYear, adjMonth, firstFriday + 14);

    // Must be at least minDaysOut from now
    const daysFromNow = Math.ceil((thirdFriday.getTime() - now.getTime()) / (1000 * 60 * 60 * 24));
    if (daysFromNow < (minDaysOut || 21)) continue;

    // Must be strictly AFTER the current position's expiration
    if (afterTime > 0 && thirdFriday.getTime() <= afterTime) continue;

    return thirdFriday;
  }
  // Fallback: just add days beyond afterDate
  const base = afterTime > 0 ? new Date(afterTime) : new Date(now);
  base.setDate(base.getDate() + (minDaysOut || 30));
  return base;
}

// ── Fetch real IBKR NBBO for a roll target option ──
// Returns { bid, ask, mid, last, conId } or null
async function fetchRollNBBO(symbol, strike, right, expiration) {
  try {
    // Send expiration as YYYYMMDD if it's a Date, to avoid timezone issues
    let expStr;
    if (expiration instanceof Date) {
      expStr = `${expiration.getFullYear()}${String(expiration.getMonth()+1).padStart(2,"0")}${String(expiration.getDate()).padStart(2,"0")}`;
    } else {
      expStr = String(expiration);
    }
    const params = new URLSearchParams({
      symbol, strike: String(strike), right, expiration: expStr,
    });
    console.log("[NBBO] Fetching:", params.toString());
    const res = await fetch(API + "/nbbo?" + params.toString());
    const json = await res.json();
    if (!json.success) {
      console.warn("[NBBO] Failed:", json.error);
    }
    return json.success ? json.data : null;
  } catch (err) {
    console.warn("[NBBO] Error:", err);
    return null;
  }
}

// ═══════════════════════════════════════════════════════════
//  COMPONENTS
// ═══════════════════════════════════════════════════════════

function MetricCard({ title, value, change, prefix = "", color }) {
  return (
    <div className="card">
      <div className="card-title">{title}</div>
      <div className="metric-value" style={color ? { color } : {}}>
        {prefix}{value}
      </div>
      {change !== undefined && (
        <div className={`metric-change ${change >= 0 ? "positive" : "negative"}`}>
          {change >= 0 ? "▲" : "▼"} {fmt.usd(Math.abs(change))}
        </div>
      )}
    </div>
  );
}

function GreeksDisplay({ greeks }) {
  if (!greeks) return null;
  const items = [
    { symbol: "Δ", name: "Delta", value: fmt.num(greeks.totalDelta, 1), color: "#3b82f6" },
    { symbol: "Γ", name: "Gamma", value: fmt.num(greeks.totalGamma, 2), color: "#8b5cf6" },
    { symbol: "Θ", name: "Theta", value: fmt.sign(greeks.totalTheta), color: "#f59e0b" },
    { symbol: "ν", name: "Vega", value: fmt.num(greeks.totalVega, 1), color: "#06b6d4" },
    { symbol: "β", name: "Beta Δ", value: fmt.num(greeks.betaWeightedDelta, 1), color: "#10b981" },
  ];
  return (
    <div className="greeks-row">
      {items.map((g) => (
        <div key={g.name} className="greek-item">
          <div className="greek-symbol" style={{ color: g.color }}>{g.symbol}</div>
          <div className="greek-value">{g.value}</div>
          <div className="greek-name">{g.name}</div>
        </div>
      ))}
    </div>
  );
}

// ═══════════════════════════════════════════════════════════
//  ACTION RECOMMENDATION LOGIC
// ═══════════════════════════════════════════════════════════

function getActionRecommendation(pnl, maxProfit, maxLoss, daysToExp) {
  const pnlPct = maxProfit > 0 ? (pnl / maxProfit) * 100 : 0;
  const lossPct = maxLoss < 0 ? (pnl / maxLoss) * 100 : 0;
  if (pnl > 0) {
    if (daysToExp != null && daysToExp <= 3) return { action: "close", tag: "CLOSE NOW", color: "#ef4444", reason: "Expiration imminent — close to avoid assignment risk" };
    if (pnlPct >= 75) return { action: "close", tag: "TAKE PROFIT", color: "#10b981", reason: `${pnlPct.toFixed(0)}% of max profit reached — lock it in` };
    if (daysToExp != null && daysToExp <= 7) return { action: "close", tag: "CLOSE SOON", color: "#f59e0b", reason: "Gamma risk high in last week — consider closing" };
    if (daysToExp != null && daysToExp > 30 && pnlPct > 25) return { action: "roll", tag: "ROLL FOR MORE", color: "#8b5cf6", reason: "Profitable with time — roll out for more credit" };
    return { action: "hold", tag: "HOLD", color: "#3b82f6", reason: "Let theta work for you" };
  }
  if (pnl < 0) {
    if (daysToExp != null && daysToExp <= 3) return { action: "close", tag: "CLOSE NOW", color: "#ef4444", reason: "Expiration imminent — cut the loss" };
    if (lossPct >= 75) return { action: "roll", tag: "ROLL OUT", color: "#8b5cf6", reason: "Deep loss — roll to new expiration for recovery" };
    if (daysToExp != null && daysToExp > 21) return { action: "hold", tag: "HOLD", color: "#3b82f6", reason: "Plenty of time for recovery" };
    if (daysToExp != null && daysToExp <= 14) return { action: "roll", tag: "ROLL OUT", color: "#f59e0b", reason: "Running out of time — consider rolling" };
    return { action: "hold", tag: "MONITOR", color: "#64748b", reason: "Watch for reversal" };
  }
  return { action: "hold", tag: "BREAKEVEN", color: "#64748b", reason: "At breakeven — monitor" };
}

// ═══════════════════════════════════════════════════════════
//  CONFIRMATION POPUP MODAL
// ═══════════════════════════════════════════════════════════

function ActionConfirmModal({ action, onConfirm, onCancel }) {
  const [status, setStatus] = useState("idle"); // idle | submitting | success | error
  const [resultMsg, setResultMsg] = useState("");
  const submittingRef = useRef(false); // guard against double-submit

  // Reset state when a new action is opened
  useEffect(() => {
    if (action) {
      setStatus("idle");
      setResultMsg("");
      submittingRef.current = false;
    }
  }, [action]);

  if (!action) return null;

  const handleConfirmFn = async () => {
    // Guard: prevent double execution
    if (submittingRef.current || status !== "idle") return;
    submittingRef.current = true;
    setStatus("submitting");
    try {
      const result = await submitCloseOrder(action.legs);
      if (result.success) {
        setStatus("success");
        setResultMsg(result.message || "Order submitted successfully!");
        setTimeout(() => { submittingRef.current = false; onCancel(); }, 2500);
      } else {
        setStatus("error");
        setResultMsg(result.error || "Failed to submit order");
        submittingRef.current = false;
      }
    } catch (err) {
      setStatus("error");
      setResultMsg(String(err));
      submittingRef.current = false;
    }
  };

  // Keyboard shortcuts: Escape to cancel, Enter to confirm
  useEffect(() => {
    if (!action) return;
    const handleKey = (e) => {
      if (e.key === "Escape" && status === "idle") {
        e.preventDefault();
        onCancel();
      }
      if (e.key === "Enter" && status === "idle" && !submittingRef.current) {
        e.preventDefault();
        handleConfirmFn();
      }
    };
    window.addEventListener("keydown", handleKey);
    return () => window.removeEventListener("keydown", handleKey);
  }, [action, status]);

  const netCredit = action.legs.reduce((sum, l) => {
    const dir = l.side === "sell" ? 1 : -1;
    return sum + dir * (l.price || 0) * (l.quantity || 1) * 100;
  }, 0);

  return (
    <div style={{
      position: "fixed", top: 0, left: 0, right: 0, bottom: 0,
      background: "rgba(0,0,0,0.7)", backdropFilter: "blur(4px)",
      display: "flex", alignItems: "center", justifyContent: "center",
      zIndex: 10000, animation: "fadeIn 0.15s ease-out",
    }} onClick={(e) => { if (e.target === e.currentTarget && status !== "submitting") onCancel(); }}>
      <div style={{
        background: "var(--card-bg, #1e293b)", border: "1px solid rgba(255,255,255,0.1)",
        borderRadius: 12, padding: 0, maxWidth: 580, width: "95%",
        boxShadow: "0 25px 50px rgba(0,0,0,0.5)", animation: "slideUp 0.2s ease-out",
      }} onClick={(e) => e.stopPropagation()}>
        {/* Header */}
        <div style={{
          padding: "16px 20px", borderBottom: "1px solid rgba(255,255,255,0.08)",
          display: "flex", alignItems: "center", justifyContent: "space-between",
        }}>
          <div style={{ display: "flex", alignItems: "center", gap: 10 }}>
            <span style={{ fontSize: 20 }}>{action.icon || "⚡"}</span>
            <div>
              <div style={{ fontSize: 16, fontWeight: 700, color: "var(--text-primary)" }}>{action.name}</div>
              {action.strategyName && <div style={{ fontSize: 11, color: "var(--text-muted)" }}>{action.strategyName}</div>}
            </div>
          </div>
          {action.recommended && (
            <span style={{ padding: "3px 10px", borderRadius: 12, fontSize: 10, fontWeight: 700,
              background: "rgba(16,185,129,0.15)", color: "#10b981", border: "1px solid rgba(16,185,129,0.3)",
              letterSpacing: 0.5 }}>⭐ RECOMMENDED</span>
          )}
          {!action.recommended && action.tag && (
            <span style={{ padding: "3px 10px", borderRadius: 12, fontSize: 10, fontWeight: 700,
              background: `${action.tagColor || "#64748b"}22`, color: action.tagColor || "#64748b",
              border: `1px solid ${action.tagColor || "#64748b"}44`, letterSpacing: 0.5 }}>{action.tag}</span>
          )}
        </div>

        {/* Legs Table */}
        <div style={{ padding: "12px 20px" }}>
          <table style={{ width: "100%", borderCollapse: "collapse", fontSize: 12 }}>
            <thead>
              <tr style={{ color: "var(--text-muted)", fontSize: 10, textTransform: "uppercase", letterSpacing: 1 }}>
                <th style={{ textAlign: "left", padding: "4px 6px" }}>Action</th>
                <th style={{ textAlign: "left", padding: "4px 6px" }}>Symbol</th>
                <th style={{ textAlign: "left", padding: "4px 6px" }}>Type</th>
                <th style={{ textAlign: "right", padding: "4px 6px" }}>Strike</th>
                <th style={{ textAlign: "right", padding: "4px 6px" }}>Qty</th>
                <th style={{ textAlign: "right", padding: "4px 6px" }}>Price</th>
              </tr>
            </thead>
            <tbody>
              {action.legs.map((leg, li) => (
                <tr key={li} style={{ borderTop: "1px solid rgba(255,255,255,0.05)" }}>
                  <td style={{ padding: "6px", fontWeight: 700, color: leg.side === "buy" ? "#10b981" : "#ef4444" }}>
                    {leg.side.toUpperCase()}
                  </td>
                  <td style={{ padding: "6px", color: "var(--text-primary)" }}>{leg.symbol}</td>
                  <td style={{ padding: "6px" }}>
                    <span style={{ padding: "2px 6px", borderRadius: 4, fontSize: 10, fontWeight: 600,
                      background: leg.type === "call" ? "rgba(59,130,246,0.2)" : "rgba(239,68,68,0.2)",
                      color: leg.type === "call" ? "#60a5fa" : "#f87171" }}>
                      {leg.type.toUpperCase()}
                    </span>
                  </td>
                  <td style={{ padding: "6px", textAlign: "right", color: "var(--text-primary)" }}>${leg.strike}</td>
                  <td style={{ padding: "6px", textAlign: "right", color: "var(--text-primary)" }}>{leg.quantity}</td>
                  <td style={{ padding: "6px", textAlign: "right", color: "var(--text-secondary)" }}>${(leg.price || 0).toFixed(2)}/sh</td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>

        {/* Summary */}
        <div style={{
          padding: "12px 20px", borderTop: "1px solid rgba(255,255,255,0.08)",
          display: "flex", gap: 20, flexWrap: "wrap", fontSize: 12,
        }}>
          <div>
            <div style={{ color: "var(--text-muted)", fontSize: 10 }}>NET {netCredit >= 0 ? "CREDIT" : "DEBIT"}</div>
            <div style={{ fontWeight: 700, fontSize: 16, color: netCredit >= 0 ? "#10b981" : "#ef4444" }}>
              {netCredit >= 0 ? "+$" : "-$"}{Math.abs(netCredit).toFixed(2)}
            </div>
          </div>
          {action.estimatedPnL != null && (
            <div>
              <div style={{ color: "var(--text-muted)", fontSize: 10 }}>EST. P&L CHANGE</div>
              <div style={{ fontWeight: 700, fontSize: 16, color: action.estimatedPnL >= 0 ? "#10b981" : "#ef4444" }}>
                {action.estimatedPnL >= 0 ? "+$" : "-$"}{Math.abs(action.estimatedPnL).toFixed(2)}
              </div>
            </div>
          )}
          {action.reason && (
            <div style={{ flex: 1, minWidth: 150 }}>
              <div style={{ color: "var(--text-muted)", fontSize: 10 }}>REASON</div>
              <div style={{ fontSize: 12, color: "var(--text-secondary)" }}>{action.reason}</div>
            </div>
          )}
        </div>

        {/* IBKR Order Details — exact command being sent */}
        <div style={{
          padding: "12px 20px", borderTop: "1px solid rgba(255,255,255,0.08)",
          background: "rgba(30,41,59,0.5)",
        }}>
          <div style={{ fontSize: 10, fontWeight: 700, color: "var(--text-muted)", textTransform: "uppercase", letterSpacing: 1, marginBottom: 8 }}>
            📡 IBKR Order Details — What will be sent:
          </div>
          <div style={{ fontFamily: "monospace", fontSize: 11, lineHeight: 1.8, color: "var(--text-secondary)" }}>
            {action.legs.map((leg, li) => {
              const expDate = leg.expiration ? (
                /^\d{8}$/.test(String(leg.expiration))
                  ? new Date(parseInt(String(leg.expiration).slice(0,4)), parseInt(String(leg.expiration).slice(4,6))-1, parseInt(String(leg.expiration).slice(6,8)))
                  : new Date(leg.expiration)
              ) : null;
              const expStr = expDate ? expDate.toLocaleDateString("en-US", { weekday: "short", month: "short", day: "numeric", year: "2-digit" }) : "—";
              return (
                <div key={li} style={{ padding: "6px 8px", borderRadius: 4, marginBottom: 4,
                  background: "rgba(0,0,0,0.3)", border: "1px solid rgba(255,255,255,0.05)" }}>
                  <div style={{ display: "flex", gap: 16, flexWrap: "wrap" }}>
                    <span><b style={{ color: leg.side === "buy" ? "#10b981" : "#ef4444" }}>Leg {li+1}: {leg.side.toUpperCase()}</b></span>
                    <span>Qty: <b>{leg.quantity}</b></span>
                    <span>Symbol: <b>{leg.symbol}</b></span>
                    <span>SecType: <b>{leg.type === "call" || leg.type === "put" ? "OPT" : "STK"}</b></span>
                    {(leg.type === "call" || leg.type === "put") && (
                      <>
                        <span>Right: <b>{leg.type === "call" ? "CALL" : "PUT"}</b></span>
                        <span>Strike: <b>${leg.strike}</b></span>
                        <span>Exp: <b>{leg.expiration}</b> ({expStr})</span>
                        <span>Multiplier: <b>100</b></span>
                      </>
                    )}
                  </div>
                  <div style={{ display: "flex", gap: 16, marginTop: 2, color: "var(--text-muted)" }}>
                    <span>Exchange: <b>{leg.exchange || "SMART"}</b></span>
                    <span>OrderType: <b>LMT</b></span>
                    <span>Limit: <b>${(leg.price || 0).toFixed(2)}</b></span>
                    <span>TIF: <b>DAY</b></span>
                  </div>
                </div>
              );
            })}
          </div>
          <div style={{ fontSize: 10, color: "var(--text-muted)", marginTop: 6, fontStyle: "italic" }}>
            💡 POST /api/close → submitStrategy() → placeOrder() to IBKR TWS/Gateway
          </div>
        </div>

        {/* Action Buttons */}
        <div style={{
          padding: "16px 20px", borderTop: "1px solid rgba(255,255,255,0.08)",
          display: "flex", gap: 10, justifyContent: "flex-end",
        }}>
          {status === "idle" && (
            <>
              <button style={{
                padding: "10px 20px", fontSize: 13, fontWeight: 600,
                background: "rgba(100,116,139,0.2)", color: "var(--text-secondary)",
                border: "1px solid rgba(100,116,139,0.3)", borderRadius: 8, cursor: "pointer",
              }} onClick={onCancel}>✗ Cancel <span style={{ fontSize: 10, opacity: 0.6 }}>(Esc)</span></button>
              <button style={{
                padding: "10px 24px", fontSize: 13, fontWeight: 700,
                background: "var(--accent-green)", color: "#000",
                border: "none", borderRadius: 8, cursor: "pointer",
              }} onClick={handleConfirmFn}>✓ Confirm & Execute <span style={{ fontSize: 10, opacity: 0.6 }}>(Enter)</span></button>
            </>
          )}
          {status === "submitting" && (
            <span style={{ color: "var(--accent-amber)", fontWeight: 600, fontSize: 13, animation: "pulse 1s infinite" }}>
              ⏳ Submitting to IBKR...
            </span>
          )}
          {status === "success" && (
            <span style={{ color: "var(--accent-green)", fontWeight: 600, fontSize: 13 }}>
              ✅ {resultMsg}
            </span>
          )}
          {status === "error" && (
            <div style={{ display: "flex", gap: 10, alignItems: "center" }}>
              <span style={{ color: "var(--accent-red)", fontSize: 12 }}>❌ {resultMsg}</span>
              <button style={{
                padding: "8px 16px", fontSize: 12, fontWeight: 600,
                background: "rgba(239,68,68,0.15)", color: "var(--accent-red)",
                border: "1px solid rgba(239,68,68,0.3)", borderRadius: 6, cursor: "pointer",
              }} onClick={() => { setStatus("idle"); setResultMsg(""); }}>Retry</button>
              <button style={{
                padding: "8px 16px", fontSize: 12, fontWeight: 600,
                background: "rgba(100,116,139,0.2)", color: "var(--text-secondary)",
                border: "1px solid rgba(100,116,139,0.3)", borderRadius: 6, cursor: "pointer",
              }} onClick={onCancel}>Close</button>
            </div>
          )}
        </div>
      </div>
    </div>
  );
}

// ═══════════════════════════════════════════════════════════
//  STRATEGY PAYOFF CHART (inline in position cards)
// ═══════════════════════════════════════════════════════════

function StrategyPayoffChart({ legs, underlying, allPositions, actualPnL }) {
  const [livePrice, setLivePrice] = useState(null);
  const [priceDelayed, setPriceDelayed] = useState(false);

  // Fetch real underlying price from IBKR (auto-falls back to delayed)
  useEffect(() => {
    if (!underlying) return;
    let cancelled = false;
    apiFetch("/quote/" + encodeURIComponent(underlying)).then(data => {
      if (!cancelled && data && data.price > 0) {
        setLivePrice(data.price);
        setPriceDelayed(!!data.delayed);
      }
    });
    return () => { cancelled = true; };
  }, [underlying]);

  // Compute entry prices from position data
  const chartLegs = legs.map(l => {
    const mult = l.contract.multiplier || 100;
    const entryPerShare = l.averageCost ? Math.abs(l.averageCost) / mult : 0;
    return {
      strike: l.contract.strike,
      type: l.contract.type, // "call" or "put"
      side: l.quantity > 0 ? "buy" : "sell",
      quantity: Math.abs(l.quantity),
      price: entryPerShare,
    };
  });

  // Get current underlying price: only from real sources (IBKR quote or stock position)
  // No fallback to strike midpoint — if no real data, don't show the price marker
  let currentPrice = livePrice || 0;
  if (currentPrice <= 0 && allPositions) {
    const stock = allPositions.find(p =>
      (p.contract.symbol === underlying || p.contract.underlying === underlying) &&
      p.contract.type === "stock" && p.quantity > 0 && p.marketValue > 0
    );
    if (stock) currentPrice = stock.marketValue / stock.quantity;
  }

  // Generate payoff curve
  const strikes = chartLegs.map(l => l.strike).filter(Boolean);
  if (strikes.length === 0) return null;
  const minStrike = Math.min(...strikes);
  const maxStrike = Math.max(...strikes);
  const spread = Math.max(maxStrike - minStrike, 10);
  const center = (minStrike + maxStrike) / 2;
  const lo = center - spread * 2;
  const hi = center + spread * 2;
  const step = (hi - lo) / 60;

  const points = [];
  let maxProfit = -Infinity, maxLoss = Infinity;
  for (let price = lo; price <= hi; price += step) {
    let pnl = 0;
    for (const leg of chartLegs) {
      const dir = leg.side === "buy" ? 1 : -1;
      const intrinsic = leg.type === "call"
        ? Math.max(price - leg.strike, 0)
        : Math.max(leg.strike - price, 0);
      pnl += (intrinsic - leg.price) * dir * leg.quantity * 100;
    }
    pnl = Math.round(pnl);
    points.push({ price: Math.round(price * 100) / 100, pnl });
    if (pnl > maxProfit) maxProfit = pnl;
    if (pnl < maxLoss) maxLoss = pnl;
  }

  // Use actual unrealized P&L from position data (matches the text above)
  // actualPnL comes from strat.legs.reduce(unrealizedPnL) — the real market P&L
  const currentPnL = actualPnL != null ? Math.round(actualPnL * 100) / 100 : 0;

  // Also compute expiration P&L at current price (for tooltip context)
  let expirationPnL = 0;
  if (currentPrice > 0) {
    for (const leg of chartLegs) {
      const dir = leg.side === "buy" ? 1 : -1;
      const intrinsic = leg.type === "call"
        ? Math.max(currentPrice - leg.strike, 0)
        : Math.max(leg.strike - currentPrice, 0);
      expirationPnL += (intrinsic - leg.price) * dir * leg.quantity * 100;
    }
    expirationPnL = Math.round(expirationPnL);
  }

  // Breakeven points
  const breakevens = [];
  for (let i = 1; i < points.length; i++) {
    if ((points[i - 1].pnl < 0 && points[i].pnl >= 0) || (points[i - 1].pnl >= 0 && points[i].pnl < 0)) {
      // Linear interpolation
      const ratio = Math.abs(points[i - 1].pnl) / (Math.abs(points[i - 1].pnl) + Math.abs(points[i].pnl));
      breakevens.push(Math.round((points[i - 1].price + ratio * (points[i].price - points[i - 1].price)) * 100) / 100);
    }
  }

  // Unique gradient ID to avoid conflicts across multiple charts
  const gradId = useMemo(() => "stratGrad_" + Math.random().toString(36).slice(2, 8), []);

  return (
    <div style={{ marginBottom: 12 }}>
      <div style={{ display: "flex", justifyContent: "space-between", alignItems: "center", marginBottom: 6 }}>
        <div style={{ fontSize: 12, fontWeight: 600, color: "var(--text-secondary)" }}>
          Payoff at Expiration
        </div>
        <div style={{ display: "flex", gap: 12, fontSize: 10, color: "var(--text-muted)", flexWrap: "wrap" }}>
          {currentPrice > 0 && <span>{underlying}: <b style={{ color: "var(--accent-amber)" }}>${currentPrice.toFixed(2)}</b>{priceDelayed && <span style={{ color: "#f59e0b", fontSize: 9, marginLeft: 4, padding: "1px 4px", background: "rgba(245,158,11,0.15)", borderRadius: 3 }}>DELAYED</span>}</span>}
          {currentPrice <= 0 && <span>{underlying}: <b style={{ color: "var(--text-muted)" }}>Loading... ⏳</b></span>}
          <span>Current P&L: <b style={{ color: currentPnL >= 0 ? "var(--accent-green)" : "var(--accent-red)" }}>{fmt.sign(currentPnL)}</b></span>
          <span>Max Profit: <b style={{ color: "var(--accent-green)" }}>{fmt.sign(maxProfit)}</b></span>
          <span>Max Loss: <b style={{ color: "var(--accent-red)" }}>{fmt.sign(maxLoss)}</b></span>
          {breakevens.map((be, i) => (
            <span key={i}>BE: <b style={{ color: "var(--accent-amber)" }}>${be}</b></span>
          ))}
        </div>
      </div>
      <ResponsiveContainer width="100%" height={180}>
        <AreaChart data={points} margin={{ top: 5, right: 10, left: 10, bottom: 0 }}>
          <defs>
            <linearGradient id={gradId} x1="0" y1="0" x2="0" y2="1">
              <stop offset="0%" stopColor="#10b981" stopOpacity={0.25} />
              <stop offset="50%" stopColor="#10b981" stopOpacity={0.02} />
              <stop offset="50%" stopColor="#ef4444" stopOpacity={0.02} />
              <stop offset="100%" stopColor="#ef4444" stopOpacity={0.25} />
            </linearGradient>
          </defs>
          <CartesianGrid strokeDasharray="3 3" stroke="rgba(100,116,139,0.15)" />
          <XAxis dataKey="price" tick={{ fill: "#64748b", fontSize: 9 }} tickFormatter={v => "$" + v}
            domain={[lo, hi]} type="number" />
          <YAxis tick={{ fill: "#64748b", fontSize: 9 }}
            tickFormatter={v => v >= 0 ? "$" + v : "-$" + Math.abs(v)} />
          <Tooltip
            contentStyle={{ background: "#1e293b", border: "1px solid #334155", borderRadius: 8, fontSize: 11 }}
            labelFormatter={v => "Price: $" + v}
            formatter={v => [v >= 0 ? "+$" + v : "-$" + Math.abs(v), "P&L"]}
          />
          {/* Zero line */}
          <ReferenceLine y={0} stroke="#475569" strokeDasharray="4 4" />
          {/* Breakeven markers */}
          {breakevens.map((be, i) => (
            <ReferenceLine key={i} x={be} stroke="#f59e0b" strokeDasharray="3 3" strokeOpacity={0.5} />
          ))}
          {/* Strike markers */}
          {strikes.map((s, i) => (
            <ReferenceLine key={"s" + i} x={s} stroke="rgba(139,92,246,0.3)" strokeDasharray="2 4" />
          ))}
          {/* P&L area */}
          <Area type="monotone" dataKey="pnl" stroke="#3b82f6" strokeWidth={2}
            fill={"url(#" + gradId + ")"} />
          {/* Current price marker — rendered AFTER Area so it's on top */}
          {currentPrice > 0 && (
            <ReferenceLine x={Math.round(currentPrice * 100) / 100} stroke="#f59e0b" strokeWidth={3}
              label={{ value: `📍 $${currentPrice.toFixed(2)}${priceDelayed ? " (D)" : ""} | Now: ${currentPnL >= 0 ? "+$" : "-$"}${Math.abs(currentPnL).toFixed(2)} | Exp: ${expirationPnL >= 0 ? "+$" : "-$"}${Math.abs(expirationPnL).toFixed(0)}`,
                position: "top", fill: "#f59e0b", fontSize: 11, fontWeight: 700 }} />
          )}
          {/* Dot on the curve at current price */}
          {currentPrice > 0 && (() => {
            const nearest = points.reduce((best, p) => Math.abs(p.price - currentPrice) < Math.abs(best.price - currentPrice) ? p : best, points[0]);
            return <ReferenceDot x={nearest.price} y={nearest.pnl} r={6} fill="#f59e0b" stroke="#fff" strokeWidth={2} />;
          })()}
        </AreaChart>
      </ResponsiveContainer>
    </div>
  );
}

function PositionsTable({ positions }) {
  const [expandedPos, setExpandedPos] = useState(null);
  const [showCloseManual, setShowCloseManual] = useState(null);
  const [expandedStrategy, setExpandedStrategy] = useState(null);
  const [closeStatus, setCloseStatus] = useState({}); // { [key]: "confirming"|"submitting"|"success"|"error" }
  const [closeMessage, setCloseMessage] = useState({}); // { [key]: string }
  const [liveNBBO, setLiveNBBO] = useState({}); // { [cacheKey]: { bid, ask, mid, last } | "loading" }
  const [confirmAction, setConfirmAction] = useState(null); // null=closed, object=modal open

  // ── Fetch live IBKR NBBO when a losing position is expanded ──
  useEffect(() => {
    if (expandedPos == null) return;
    const p = positions[expandedPos];
    if (!p) return;
    const type = p.contract.type;
    const isOption = type === "call" || type === "put";
    if (!isOption) return;
    const pnl = p.unrealizedPnL || 0;
    if (pnl >= 0) return; // only for losing positions with recovery options

    const underlying = p.contract.underlying || (p.contract.symbol || "").replace(/\d.*/, "") || p.contract.symbol;
    const right = type === "call" ? "C" : "P";
    const rollStrikeDiff = 5;
    const currentExp = parseExpDate(p.contract.expiration);
    const newExpDate = nextMonthlyExpiration(21, currentExp);
    // Build YYYYMMDD using local timezone (not UTC!) to avoid date shift
    const newExpYYYYMMDD = `${newExpDate.getFullYear()}${String(newExpDate.getMonth()+1).padStart(2,"0")}${String(newExpDate.getDate()).padStart(2,"0")}`;

    // Roll Out target: same strike, new expiration
    const rollOutKey = `${underlying}-${right}-${p.contract.strike}-${newExpDate.getTime()}`;
    // Roll shift target: shifted strike, new expiration
    const shiftedStrike = type === "put" ? p.contract.strike - rollStrikeDiff : p.contract.strike + rollStrikeDiff;
    const rollShiftKey = `${underlying}-${right}-${shiftedStrike}-${newExpDate.getTime()}`;

    const fetchIfNeeded = async (key, symbol, strike, optRight, expiration) => {
      // Skip if already loaded or loading
      if (liveNBBO[key] && liveNBBO[key] !== "error") return;
      setLiveNBBO(prev => ({ ...prev, [key]: "loading" }));
      try {
        const data = await fetchRollNBBO(symbol, strike, optRight, expiration);
        setLiveNBBO(prev => ({ ...prev, [key]: data || "error" }));
      } catch {
        setLiveNBBO(prev => ({ ...prev, [key]: "error" }));
      }
    };

    fetchIfNeeded(rollOutKey, underlying, p.contract.strike, right, newExpYYYYMMDD);
    fetchIfNeeded(rollShiftKey, underlying, shiftedStrike, right, newExpYYYYMMDD);
  }, [expandedPos, positions]);

  // Open the confirmation modal for any action
  const openActionModal = (actionObj) => {
    setConfirmAction(actionObj);
  };

  const handleClose = async (key, legs) => {
    if (closeStatus[key] !== "confirming") {
      setCloseStatus(prev => ({ ...prev, [key]: "confirming" }));
      setCloseMessage(prev => ({ ...prev, [key]: "" }));
      return;
    }
    setCloseStatus(prev => ({ ...prev, [key]: "submitting" }));
    try {
      const result = await submitCloseOrder(legs);
      if (result.success) {
        setCloseStatus(prev => ({ ...prev, [key]: "success" }));
        setCloseMessage(prev => ({ ...prev, [key]: result.message || "Order submitted!" }));
      } else {
        setCloseStatus(prev => ({ ...prev, [key]: "error" }));
        setCloseMessage(prev => ({ ...prev, [key]: result.error || "Failed to submit" }));
      }
    } catch (err) {
      setCloseStatus(prev => ({ ...prev, [key]: "error" }));
      setCloseMessage(prev => ({ ...prev, [key]: String(err) }));
    }
  };

  const cancelClose = (key) => {
    setCloseStatus(prev => ({ ...prev, [key]: null }));
    setCloseMessage(prev => ({ ...prev, [key]: "" }));
  };

  if (!positions?.length) return <div className="loading">No positions loaded</div>;

  // ── Detect multi-leg strategies ──
  const optionPositions = positions.map((p, i) => ({ ...p, _idx: i })).filter(p => p.contract.type === "call" || p.contract.type === "put");
  const stockPositions = positions.map((p, i) => ({ ...p, _idx: i })).filter(p => p.contract.type === "stock");

  // Group options by underlying + expiration
  const groups = {};
  optionPositions.forEach(p => {
    const underlying = p.contract.underlying || p.contract.symbol || "?";
    const exp = p.contract.expiration || "none";
    const key = `${underlying}|${exp}`;
    if (!groups[key]) groups[key] = [];
    groups[key].push(p);
  });

  // Detect known strategies
  const detectedStrategies = [];
  const usedIndices = new Set();

  Object.entries(groups).forEach(([key, legs]) => {
    if (legs.length < 2) return;
    const [underlying, exp] = key.split("|");
    const calls = legs.filter(l => l.contract.type === "call").sort((a, b) => a.contract.strike - b.contract.strike);
    const puts = legs.filter(l => l.contract.type === "put").sort((a, b) => a.contract.strike - b.contract.strike);

    // Bull Call Spread: long lower-strike call + short higher-strike call
    if (calls.length >= 2) {
      for (let i = 0; i < calls.length - 1; i++) {
        for (let j = i + 1; j < calls.length; j++) {
          if (calls[i].quantity > 0 && calls[j].quantity < 0 && !usedIndices.has(calls[i]._idx) && !usedIndices.has(calls[j]._idx)) {
            detectedStrategies.push({
              name: "Bull Call Spread", underlying, expiration: exp,
              legs: [calls[i], calls[j]], indices: [calls[i]._idx, calls[j]._idx],
              icon: "📈",
            });
            usedIndices.add(calls[i]._idx); usedIndices.add(calls[j]._idx);
          } else if (calls[i].quantity < 0 && calls[j].quantity > 0 && !usedIndices.has(calls[i]._idx) && !usedIndices.has(calls[j]._idx)) {
            detectedStrategies.push({
              name: "Bear Call Spread", underlying, expiration: exp,
              legs: [calls[i], calls[j]], indices: [calls[i]._idx, calls[j]._idx],
              icon: "📉",
            });
            usedIndices.add(calls[i]._idx); usedIndices.add(calls[j]._idx);
          }
        }
      }
    }

    // Bear Put Spread: long higher-strike put + short lower-strike put
    // Bull Put Spread: short higher-strike put + long lower-strike put
    if (puts.length >= 2) {
      for (let i = 0; i < puts.length - 1; i++) {
        for (let j = i + 1; j < puts.length; j++) {
          if (puts[i].quantity < 0 && puts[j].quantity > 0 && !usedIndices.has(puts[i]._idx) && !usedIndices.has(puts[j]._idx)) {
            detectedStrategies.push({
              name: "Bear Put Spread", underlying, expiration: exp,
              legs: [puts[i], puts[j]], indices: [puts[i]._idx, puts[j]._idx],
              icon: "📉",
            });
            usedIndices.add(puts[i]._idx); usedIndices.add(puts[j]._idx);
          } else if (puts[i].quantity > 0 && puts[j].quantity < 0 && !usedIndices.has(puts[i]._idx) && !usedIndices.has(puts[j]._idx)) {
            detectedStrategies.push({
              name: "Bull Put Spread", underlying, expiration: exp,
              legs: [puts[i], puts[j]], indices: [puts[i]._idx, puts[j]._idx],
              icon: "📈",
            });
            usedIndices.add(puts[i]._idx); usedIndices.add(puts[j]._idx);
          }
        }
      }
    }

    // Straddle: same strike call + put
    calls.forEach(c => {
      puts.forEach(p => {
        if (c.contract.strike === p.contract.strike && !usedIndices.has(c._idx) && !usedIndices.has(p._idx)
            && ((c.quantity > 0 && p.quantity > 0) || (c.quantity < 0 && p.quantity < 0))) {
          const isShort = c.quantity < 0;
          detectedStrategies.push({
            name: isShort ? "Short Straddle" : "Long Straddle", underlying, expiration: exp,
            legs: [c, p], indices: [c._idx, p._idx],
            icon: isShort ? "🔻" : "🔀",
          });
          usedIndices.add(c._idx); usedIndices.add(p._idx);
        }
      });
    });

    // Strangle: different strike call + put
    calls.forEach(c => {
      puts.forEach(p => {
        if (c.contract.strike !== p.contract.strike && !usedIndices.has(c._idx) && !usedIndices.has(p._idx)
            && ((c.quantity > 0 && p.quantity > 0) || (c.quantity < 0 && p.quantity < 0))) {
          const isShort = c.quantity < 0;
          detectedStrategies.push({
            name: isShort ? "Short Strangle" : "Long Strangle", underlying, expiration: exp,
            legs: [c, p], indices: [c._idx, p._idx],
            icon: isShort ? "🔻" : "🔀",
          });
          usedIndices.add(c._idx); usedIndices.add(p._idx);
        }
      });
    });
  });

  // Iron Condor: check if we can combine a bull put spread + bear call spread on same underlying
  for (let i = 0; i < detectedStrategies.length; i++) {
    for (let j = i + 1; j < detectedStrategies.length; j++) {
      const a = detectedStrategies[i], b = detectedStrategies[j];
      if (a.underlying === b.underlying && a.expiration === b.expiration) {
        if ((a.name === "Bull Put Spread" && b.name === "Bear Call Spread") ||
            (a.name === "Bear Call Spread" && b.name === "Bull Put Spread")) {
          const bps = a.name === "Bull Put Spread" ? a : b;
          const bcs = a.name === "Bear Call Spread" ? a : b;
          const combined = {
            name: "Iron Condor", underlying: a.underlying, expiration: a.expiration,
            legs: [...bps.legs, ...bcs.legs],
            indices: [...bps.indices, ...bcs.indices],
            icon: "🦅",
          };
          // Remove both, add combined
          detectedStrategies.splice(Math.max(i, j), 1);
          detectedStrategies.splice(Math.min(i, j), 1);
          detectedStrategies.push(combined);
          break;
        }
      }
    }
  }

  // Covered Call: stock + short call on same underlying
  stockPositions.forEach(stock => {
    const stockSym = stock.contract.symbol || "?";
    optionPositions.forEach(opt => {
      const optUnderlying = opt.contract.underlying || opt.contract.symbol || "?";
      if (optUnderlying === stockSym && opt.contract.type === "call" && opt.quantity < 0
          && !usedIndices.has(opt._idx)) {
        detectedStrategies.push({
          name: "Covered Call", underlying: stockSym, expiration: opt.contract.expiration || "none",
          legs: [stock, opt], indices: [stock._idx, opt._idx],
          icon: "🛡️",
        });
        usedIndices.add(stock._idx); usedIndices.add(opt._idx);
      }
    });
  });

  // Protective Put: stock + long put on same underlying
  stockPositions.forEach(stock => {
    const stockSym = stock.contract.symbol || "?";
    optionPositions.forEach(opt => {
      const optUnderlying = opt.contract.underlying || opt.contract.symbol || "?";
      if (optUnderlying === stockSym && opt.contract.type === "put" && opt.quantity > 0
          && !usedIndices.has(opt._idx)) {
        detectedStrategies.push({
          name: "Protective Put", underlying: stockSym, expiration: opt.contract.expiration || "none",
          legs: [stock, opt], indices: [stock._idx, opt._idx],
          icon: "🛡️",
        });
        usedIndices.add(stock._idx); usedIndices.add(opt._idx);
      }
    });
  });

  return (
    <>
    <table className="table">
      <thead>
        <tr>
          <th>Symbol</th><th>Type</th><th>Expiration</th><th>Qty</th><th>Avg Cost</th>
          <th>Premium Paid/Rcvd</th><th>Mkt Value</th><th>P&L</th><th>Delta</th><th>Theta</th>
        </tr>
      </thead>
      <tbody>
        {/* ── Detected strategy group rows ── */}
        {detectedStrategies.map((strat, si) => {
          const totalPnL = strat.legs.reduce((s, l) => s + (l.unrealizedPnL || 0), 0);
          const totalMktVal = strat.legs.reduce((s, l) => s + (l.marketValue || 0), 0);
          const totalDelta = strat.legs.reduce((s, l) => s + (l.greeks?.delta || 0) * l.quantity, 0);
          const totalTheta = strat.legs.reduce((s, l) => s + (l.greeks?.theta || 0) * Math.abs(l.quantity), 0);
          const expDate = strat.expiration && strat.expiration !== "none" ? parseExpDate(strat.expiration) : null;
          const daysToExp = expDate ? Math.ceil((expDate.getTime() - Date.now()) / (1000 * 60 * 60 * 24)) : null;
          const isExpanded = expandedStrategy === si;

          return (
            <React.Fragment key={`strat-${si}`}>
              <tr className="strategy-group-row strategy-group-clickable"
                onClick={() => setExpandedStrategy(isExpanded ? null : si)}>
                <td>
                  <div className="strategy-group-label">
                    <span className="strategy-group-badge">{strat.icon} {strat.name}</span>
                    <span style={{ fontWeight: 600 }}>{strat.underlying}</span>
                    {(() => {
                      const strikes = strat.legs
                        .filter(l => l.contract.type === "call" || l.contract.type === "put")
                        .map(l => `$${l.contract.strike}`)
                        .join("/");
                      return strikes ? <span style={{ fontSize: 11, color: "var(--text-secondary)" }}>{strikes}</span> : null;
                    })()}
                    <span style={{ fontSize: 10, color: "var(--text-muted)" }}>{isExpanded ? "▲" : "▼"}</span>
                  </div>
                </td>
                <td>
                  <div className="strategy-group-legs">
                    {strat.legs.map((l, li) => {
                      const lt = l.contract.type;
                      const isOpt = lt === "call" || lt === "put";
                      return (
                        <span key={li} className="strategy-group-leg">
                          {l.quantity > 0 ? "+" : ""}{l.quantity} {lt.toUpperCase()}
                          {isOpt && l.contract.strike ? ` $${l.contract.strike}` : ""}
                        </span>
                      );
                    })}
                  </div>
                </td>
                <td>
                  {expDate ? (
                    <span className={`exp-badge ${daysToExp <= 7 ? "exp-danger" : daysToExp <= 21 ? "exp-warning" : "exp-safe"}`}>
                      {expDate.toLocaleDateString("en-US", { month: "short", day: "numeric" })}
                      <span style={{ marginLeft: 4, opacity: 0.8 }}>({daysToExp}d)</span>
                    </span>
                  ) : "—"}
                </td>
                <td style={{ color: "var(--accent-purple)", fontWeight: 600 }}>
                  {strat.legs.length} legs
                </td>
                <td>—</td>
                <td>—</td>
                <td>{fmt.usd(totalMktVal)}</td>
                <td className={totalPnL >= 0 ? "positive" : "negative"} style={{ fontWeight: 700 }}>
                  {fmt.sign(totalPnL)}
                </td>
                <td>{fmt.num(totalDelta, 3)}</td>
                <td>{fmt.sign(totalTheta)}</td>
              </tr>

              {/* ── Expanded strategy close analysis ── */}
              {isExpanded && (
                <tr>
                  <td colSpan={10} style={{ padding: 0 }}>
                    <div className="strategy-close-panel">

                      {/* Strategy verdict banner */}
                      {totalPnL > 0 ? (
                        <div className="strategy-close-verdict pos-verdict-profit">
                          <div className="pos-verdict-icon">✅</div>
                          <div className="pos-verdict-text">
                            <div className="pos-verdict-title">
                              Close Entire {strat.name} = PROFIT of {fmt.usd(totalPnL)}
                            </div>
                            <div className="pos-verdict-sub">
                              Closing all {strat.legs.length} legs together results in a net profit. Individual leg P&Ls are shown below.
                            </div>
                          </div>
                          <div className="pos-close-pnl-badge" style={{ background: "rgba(16,185,129,0.2)", color: "var(--accent-green)", fontSize: 20, fontWeight: 800, padding: "8px 16px" }}>
                            +{fmt.usd(totalPnL)}
                          </div>
                        </div>
                      ) : totalPnL < 0 ? (
                        <div className="strategy-close-verdict pos-verdict-loss">
                          <div className="pos-verdict-icon">❌</div>
                          <div className="pos-verdict-text">
                            <div className="pos-verdict-title">
                              Close Entire {strat.name} = LOSS of {fmt.usd(Math.abs(totalPnL))}
                            </div>
                            <div className="pos-verdict-sub">
                              Closing all legs together results in a net loss. Consider adjusting individual legs or rolling the strategy.
                            </div>
                          </div>
                          <div className="pos-close-pnl-badge" style={{ background: "rgba(239,68,68,0.2)", color: "var(--accent-red)", fontSize: 20, fontWeight: 800, padding: "8px 16px" }}>
                            {fmt.usd(totalPnL)}
                          </div>
                        </div>
                      ) : (
                        <div className="strategy-close-verdict pos-verdict-breakeven">
                          <div className="pos-verdict-icon">⚖️</div>
                          <div className="pos-verdict-text">
                            <div className="pos-verdict-title">Close Entire {strat.name} = BREAKEVEN</div>
                            <div className="pos-verdict-sub">Combined P&L is zero across all legs.</div>
                          </div>
                          <div className="pos-close-pnl-badge" style={{ background: "rgba(245,158,11,0.2)", color: "var(--accent-amber)", fontSize: 20, fontWeight: 800, padding: "8px 16px" }}>
                            $0
                          </div>
                        </div>
                      )}

                      {/* Summary stats */}
                      <div className="strategy-close-summary">
                        <div className="strategy-close-summary-stat">
                          <div className="strategy-close-summary-value" style={{ color: "var(--accent-purple)" }}>
                            {strat.legs.length}
                          </div>
                          <div className="strategy-close-summary-label">Legs</div>
                        </div>
                        <div className="strategy-close-summary-stat">
                          <div className="strategy-close-summary-value" style={{
                            color: totalPnL >= 0 ? "var(--accent-green)" : "var(--accent-red)"
                          }}>
                            {fmt.sign(totalPnL)}
                          </div>
                          <div className="strategy-close-summary-label">Combined P&L</div>
                        </div>
                        <div className="strategy-close-summary-stat">
                          <div className="strategy-close-summary-value" style={{ color: "var(--accent-blue)" }}>
                            {fmt.usd(Math.abs(totalMktVal))}
                          </div>
                          <div className="strategy-close-summary-label">Market Value</div>
                        </div>
                        <div className="strategy-close-summary-stat">
                          <div className="strategy-close-summary-value" style={{
                            color: daysToExp != null && daysToExp <= 7 ? "var(--accent-red)"
                              : daysToExp != null && daysToExp <= 21 ? "var(--accent-amber)"
                              : "var(--text-primary)"
                          }}>
                            {daysToExp != null ? `${daysToExp}d` : "—"}
                          </div>
                          <div className="strategy-close-summary-label">Days to Exp</div>
                        </div>
                      </div>

                      {/* Payoff diagram */}
                      <StrategyPayoffChart legs={strat.legs} underlying={strat.underlying} allPositions={positions} actualPnL={totalPnL} />

                      {/* Per-leg breakdown table */}
                      <table className="strategy-close-legs-table">
                        <thead>
                          <tr>
                            <th>Leg</th><th>Type</th><th>Strike</th><th>Qty</th>
                            <th>Entry</th><th>Current</th><th>P&L</th><th>Close Action</th>
                          </tr>
                        </thead>
                        <tbody>
                          {strat.legs.map((l, li) => {
                            const lt = l.contract.type;
                            const isOpt = lt === "call" || lt === "put";
                            const mult = l.contract.multiplier || 100;
                            const lPerShare = isOpt ? l.averageCost / mult : l.averageCost;
                            const lCurrPerShare = l.marketValue ? Math.abs(l.marketValue) / (Math.abs(l.quantity) * (isOpt ? mult : 1)) : 0;
                            const lPnl = l.unrealizedPnL || 0;
                            const lCloseAction = l.quantity < 0 ? "BUY to Close" : "SELL to Close";
                            return (
                              <tr key={li}>
                                <td style={{ fontWeight: 600 }}>{l.contract.underlying || l.contract.symbol}</td>
                                <td><span className={`badge ${lt === "call" ? "badge-call" : lt === "put" ? "badge-put" : "badge-stock"}`}>{lt}</span></td>
                                <td>{l.contract.strike ? `$${l.contract.strike}` : "—"}</td>
                                <td style={{ color: l.quantity >= 0 ? "var(--accent-green)" : "var(--accent-red)" }}>
                                  {l.quantity > 0 ? "+" : ""}{l.quantity}
                                </td>
                                <td>{fmt.usd(lPerShare)}/sh</td>
                                <td>{fmt.usd(lCurrPerShare)}/sh</td>
                                <td className={lPnl >= 0 ? "positive" : "negative"} style={{ fontWeight: 600 }}>
                                  {fmt.sign(lPnl)}
                                </td>
                                <td>
                                  <span style={{ fontWeight: 600, color: "var(--accent-cyan)" }}>{lCloseAction}</span>
                                </td>
                              </tr>
                            );
                          })}
                          <tr style={{ borderTop: "2px solid var(--accent-purple)" }}>
                            <td colSpan={6} style={{ fontWeight: 700, textAlign: "right", color: "var(--accent-purple)" }}>
                              TOTAL (Close All Together):
                            </td>
                            <td className={totalPnL >= 0 ? "positive" : "negative"} style={{ fontWeight: 800, fontSize: 14 }}>
                              {fmt.sign(totalPnL)}
                            </td>
                            <td></td>
                          </tr>
                        </tbody>
                      </table>

                      {/* How to close the whole strategy */}
                      <div className="strategy-close-how-panel">
                        <div className="strategy-close-how-title">
                          <span>🔧</span> How to Close the Entire {strat.name} in IBKR TWS
                        </div>
                        {strat.legs.map((l, li) => {
                          const lt = l.contract.type;
                          const isOpt = lt === "call" || lt === "put";
                          const lCloseAction = l.quantity < 0 ? "BUY" : "SELL";
                          const mult = l.contract.multiplier || 100;
                          const lCurrPerShare = l.marketValue ? Math.abs(l.marketValue) / (Math.abs(l.quantity) * (isOpt ? mult : 1)) : 0;
                          const lSym = l.contract.symbol || l.contract.underlying || "?";
                          const lExp = parseExpDate(l.contract.expiration);
                          return (
                            <div key={li} style={{ marginBottom: li < strat.legs.length - 1 ? 8 : 0 }}>
                              <div style={{ display: "flex", gap: 8, alignItems: "center", fontSize: 12 }}>
                                <span style={{ fontWeight: 800, color: lCloseAction === "BUY" ? "var(--accent-red)" : "var(--accent-green)", minWidth: 36 }}>
                                  {lCloseAction}
                                </span>
                                <span style={{ fontWeight: 600 }}>
                                  {Math.abs(l.quantity)} × {lSym} {isOpt ? lt.toUpperCase() : "STOCK"}
                                  {l.contract.strike ? ` $${l.contract.strike}` : ""}
                                  {lExp ? ` ${lExp.toLocaleDateString("en-US", { month: "short", day: "numeric" })}` : ""}
                                </span>
                                <span style={{ color: "var(--text-muted)" }}>@ ~{fmt.usd(lCurrPerShare)}/sh LMT</span>
                              </div>
                            </div>
                          );
                        })}
                        <div style={{ marginTop: 10, fontSize: 11, color: "var(--text-muted)", lineHeight: 1.5 }}>
                          💡 In TWS you can close all legs at once: select the strategy → Right-click → Close Position → it will create a combo order.
                        </div>
                      </div>

                      {/* Action buttons: Copy + Auto-Execute */}
                      <div style={{ display: "flex", gap: 8, alignItems: "center", flexWrap: "wrap" }}>
                        <button className="manual-copy-btn" style={{ padding: "8px 14px", fontSize: 12 }} onClick={(e) => {
                          e.stopPropagation();
                          const lines = [`Strategy: ${strat.name} — ${strat.underlying}`, ""];
                          strat.legs.forEach((l, li) => {
                            const lt = l.contract.type;
                            const isOpt = lt === "call" || lt === "put";
                            const lCloseAction = l.quantity < 0 ? "BUY" : "SELL";
                            const mult = l.contract.multiplier || 100;
                            const lCurrPerShare = l.marketValue ? Math.abs(l.marketValue) / (Math.abs(l.quantity) * (isOpt ? mult : 1)) : 0;
                            const lExp = parseExpDate(l.contract.expiration);
                            const expIBKR = lExp ? `${lExp.getFullYear()}${String(lExp.getMonth()+1).padStart(2,"0")}${String(lExp.getDate()).padStart(2,"0")}` : "—";
                            lines.push(`Leg ${li + 1}: ${lCloseAction} ${Math.abs(l.quantity)} ${l.contract.underlying || l.contract.symbol} ${isOpt ? lt.toUpperCase() : "STOCK"} ${l.contract.strike ? `$${l.contract.strike}` : ""} Exp: ${expIBKR} @ ~$${lCurrPerShare.toFixed(2)}/sh`);
                          });
                          lines.push("", `Net P&L if closed: ${totalPnL >= 0 ? "+" : ""}$${totalPnL.toFixed(2)}`);
                          navigator.clipboard.writeText(lines.join("\n"));
                        }}>
                          📋 Copy Close Instructions
                        </button>

                        {/* ── Auto-execute close strategy via modal ── */}
                        {(() => {
                          const closingLegs = strat.legs.map(l => {
                            const lt = l.contract.type;
                            const isOpt = lt === "call" || lt === "put";
                            const mult = l.contract.multiplier || 100;
                            const lCurrPerShare = l.marketValue ? Math.abs(l.marketValue) / (Math.abs(l.quantity) * (isOpt ? mult : 1)) : 0;
                            return {
                              symbol: l.contract.underlying || l.contract.symbol,
                              type: lt,
                              strike: l.contract.strike,
                              expiration: l.contract.expiration,
                              side: l.quantity < 0 ? "buy" : "sell",
                              quantity: Math.abs(l.quantity),
                              price: roundTick(lCurrPerShare, l.contract.underlying || l.contract.symbol),
                              exchange: l.contract.exchange || "SMART",
                            };
                          });

                          // Compute max profit/loss for credit spreads
                          const totalPremiumRcvd = strat.legs.reduce((s, l) => {
                            const isOpt = l.contract.type === "call" || l.contract.type === "put";
                            const mult = l.contract.multiplier || 100;
                            return s + (l.quantity < 0 ? l.averageCost : -l.averageCost);
                          }, 0);
                          const strikes = strat.legs.filter(l => l.contract.strike).map(l => l.contract.strike);
                          const spreadWidth = strikes.length >= 2 ? (Math.max(...strikes) - Math.min(...strikes)) * 100 : 0;
                          const estMaxProfit = totalPremiumRcvd > 0 ? totalPremiumRcvd : spreadWidth > 0 ? spreadWidth - Math.abs(totalPremiumRcvd) : Math.abs(totalPremiumRcvd);
                          const estMaxLoss = totalPremiumRcvd > 0 ? -(spreadWidth - totalPremiumRcvd) : -Math.abs(totalPremiumRcvd);

                          const rec = getActionRecommendation(totalPnL, estMaxProfit, estMaxLoss, daysToExp);

                          return (
                            <div style={{ display: "flex", gap: 8, alignItems: "center", flexWrap: "wrap" }}>
                              {/* Recommendation badge */}
                              <span style={{
                                display: "inline-flex", alignItems: "center", gap: 4,
                                padding: "4px 10px", borderRadius: 6, fontSize: 11, fontWeight: 700,
                                background: `${rec.color}22`, color: rec.color,
                                border: `1px solid ${rec.color}44`,
                              }}>
                                ⭐ {rec.tag}
                              </span>
                              <span style={{ fontSize: 11, color: "var(--text-secondary)", flex: 1 }}>{rec.reason}</span>
                              <button style={{
                                padding: "8px 14px", fontSize: 12, fontWeight: 700,
                                background: totalPnL >= 0 ? "rgba(16,185,129,0.2)" : "rgba(239,68,68,0.15)",
                                color: totalPnL >= 0 ? "var(--accent-green)" : "var(--accent-red)",
                                border: `1px solid ${totalPnL >= 0 ? "rgba(16,185,129,0.4)" : "rgba(239,68,68,0.3)"}`,
                                borderRadius: 6, cursor: "pointer",
                              }} onClick={(e) => {
                                e.stopPropagation();
                                openActionModal({
                                  name: "Close " + strat.name,
                                  strategyName: `${strat.icon} ${strat.name} — ${strat.underlying}`,
                                  legs: closingLegs,
                                  estimatedPnL: totalPnL,
                                  reason: rec.reason,
                                  recommended: true,
                                  tag: rec.tag,
                                  tagColor: rec.color,
                                });
                              }}>
                                ⚡ Close Strategy via IBKR
                              </button>
                            </div>
                          );
                        })()}
                      </div>
                    </div>
                  </td>
                </tr>
              )}
            </React.Fragment>
          );
        })}

        {/* ── Individual position rows ── */}
        {positions.map((p, i) => {
          const sym = p.contract.symbol || p.contract.underlying || "?";
          const type = p.contract.type;
          const isOption = type === "call" || type === "put";
          const badgeClass = type === "call" ? "badge-call" : type === "put" ? "badge-put" : "badge-stock";
          const mult = p.contract.multiplier || 100;
          const totalPremium = isOption ? Math.abs(p.quantity) * p.averageCost : null;
          const perShareCost = isOption ? p.averageCost / mult : p.averageCost;
          const isSold = p.quantity < 0;
          const isBought = p.quantity > 0;
          const isExpanded = expandedPos === i;

          // ── Close analysis for options ──
          const pnl = p.unrealizedPnL || 0;
          const pnlPct = totalPremium && totalPremium > 0 ? (pnl / totalPremium * 100) : 0;
          const closeAction = isSold ? "BUY" : "SELL";
          const closeVerb = isSold ? "Buy to Close" : "Sell to Close";
          const currentPerShare = p.marketValue ? Math.abs(p.marketValue) / (Math.abs(p.quantity) * mult) : 0;

          // Expiration analysis
          const expDate = parseExpDate(p.contract.expiration);
          const daysToExp = expDate ? Math.ceil((expDate.getTime() - Date.now()) / (1000 * 60 * 60 * 24)) : null;
          // Current position expiration in readable + YYYYMMDD format (local timezone — no UTC shift)
          const currentExpStr = expDate ? expDate.toLocaleDateString("en-US", {
            weekday: "short", month: "short", day: "numeric", year: "2-digit",
          }) : "—";
          const currentExpIBKR = expDate ? `${expDate.getFullYear()}${String(expDate.getMonth()+1).padStart(2,"0")}${String(expDate.getDate()).padStart(2,"0")}` : "—";

          // Recommendation logic
          let recType = "neutral";
          let recIcon = "⚖️";
          let recText = "";
          if (isOption) {
            if (isSold && pnl > 0) {
              // Short option at profit
              const profitPct = totalPremium > 0 ? (pnl / totalPremium * 100) : 0;
              if (profitPct >= 50 || (daysToExp != null && daysToExp <= 7)) {
                recType = "profit"; recIcon = "✅";
                recText = profitPct >= 50
                  ? `Profit at ${profitPct.toFixed(0)}% of max — consider closing to lock in gains`
                  : `Only ${daysToExp}d to expiration — close to avoid gamma risk`;
              } else {
                recType = "neutral"; recIcon = "⏳";
                recText = `Profit at ${profitPct.toFixed(0)}% — common to close at 50%+ of max profit`;
              }
            } else if (isSold && pnl < 0) {
              recType = "loss"; recIcon = "⚠️";
              recText = `Position at a loss — evaluate if the thesis still holds or cut losses`;
            } else if (isBought && pnl > 0) {
              recType = "profit"; recIcon = "✅";
              recText = `In profit — consider taking gains before time decay accelerates`;
              if (daysToExp != null && daysToExp <= 14) {
                recText += ` (${daysToExp}d left — theta accelerating)`;
              }
            } else if (isBought && pnl < 0) {
              const lossPct = totalPremium > 0 ? (Math.abs(pnl) / totalPremium * 100) : 0;
              recType = "loss"; recIcon = "⚠️";
              recText = lossPct > 50
                ? `Down ${lossPct.toFixed(0)}% — consider closing to preserve remaining value`
                : `Down ${lossPct.toFixed(0)}% — may recover if thesis intact`;
            }
          }

          return (
            <React.Fragment key={i}>
              <tr className={`${isOption ? "pos-row-clickable" : ""} ${isExpanded ? "pos-row-expanded" : ""}`}
                onClick={() => isOption && setExpandedPos(isExpanded ? null : i)}>
                <td style={{ fontWeight: 600 }}>
                  <div style={{ display: "flex", flexDirection: "column", gap: 2 }}>
                    <span>{formatPositionName(p)}</span>
                    {isOption && (
                      <span style={{ fontSize: 10, color: "var(--text-muted)", fontFamily: "monospace" }}>
                        {sym} {isExpanded ? "▲" : "▼"}
                      </span>
                    )}
                  </div>
                </td>
                <td><span className={`badge ${badgeClass}`}>{type}</span>
                  {p.contract.strike ? ` $${p.contract.strike}` : ""}
                </td>
                <td>
                  {isOption && expDate ? (
                    <div style={{ display: "flex", flexDirection: "column", gap: 2 }}>
                      <span className={`exp-badge ${daysToExp <= 7 ? "exp-danger" : daysToExp <= 21 ? "exp-warning" : "exp-safe"}`}>
                        {expDate.toLocaleDateString("en-US", { month: "short", day: "numeric", year: "2-digit" })}
                      </span>
                      <span style={{
                        fontSize: 12, fontWeight: 700,
                        color: daysToExp <= 7 ? "var(--accent-red)" : daysToExp <= 21 ? "var(--accent-amber)" : "var(--accent-green)",
                      }}>
                        {daysToExp}d left
                      </span>
                    </div>
                  ) : type === "stock" ? "—" : "—"}
                  {usedIndices.has(i) && (
                    <span style={{ marginLeft: 6, fontSize: 9, color: "var(--accent-purple)", fontWeight: 700 }}>
                      📎 Strategy
                    </span>
                  )}
                </td>
                <td style={{ color: p.quantity >= 0 ? "var(--accent-green)" : "var(--accent-red)" }}>
                  {p.quantity > 0 ? "+" : ""}{p.quantity}
                </td>
                <td>{isOption ? fmt.usd(perShareCost) + "/sh" : fmt.usd(p.averageCost)}</td>
                <td>{isOption ? (
                  <span style={{
                    color: isSold ? "var(--accent-green)" : "var(--accent-amber)",
                    fontWeight: 600
                  }}>
                    {isSold ? "Rcvd " : "Paid "}{fmt.usd(totalPremium)}
                  </span>
                ) : "—"}</td>
                <td>{fmt.usd(p.marketValue)}</td>
                <td className={p.unrealizedPnL >= 0 ? "positive" : "negative"}>
                  {fmt.sign(p.unrealizedPnL)}
                </td>
                <td>{p.greeks ? fmt.num(p.greeks.delta, 3) : "—"}</td>
                <td>{p.greeks ? fmt.sign(p.greeks.theta) : "—"}</td>
              </tr>

              {/* ── Expanded close panel for options ──── */}
              {isExpanded && isOption && (
                <tr>
                  <td colSpan={10} style={{ padding: 0 }}>
                    <div className="pos-close-panel">

                      {/* ══ BIG VERDICT BANNER ══ */}
                      {pnl > 0 ? (
                        <div className="pos-verdict pos-verdict-profit">
                          <div className="pos-verdict-icon">✅</div>
                          <div className="pos-verdict-text">
                            <div className="pos-verdict-title">
                              Close Now = PROFIT of {fmt.usd(pnl)} (+{Math.abs(pnlPct).toFixed(1)}%)
                            </div>
                            <div className="pos-verdict-sub">
                              {isSold
                                ? <>You sold this option at <b>{fmt.usd(perShareCost)}/sh</b> and it's now worth <b>{fmt.usd(currentPerShare)}/sh</b>. It lost value → you keep the difference as profit.</>
                                : <>You bought at <b>{fmt.usd(perShareCost)}/sh</b> and it's now worth <b>{fmt.usd(currentPerShare)}/sh</b>. It gained value → you can sell for more than you paid.</>
                              }
                            </div>
                          </div>
                          <div className="pos-close-pnl-badge" style={{ background: "rgba(16,185,129,0.2)", color: "var(--accent-green)", fontSize: 20, fontWeight: 800, padding: "8px 16px" }}>
                            +{fmt.usd(pnl)}
                          </div>
                        </div>
                      ) : pnl < 0 ? (
                        <div className="pos-verdict pos-verdict-loss">
                          <div className="pos-verdict-icon">❌</div>
                          <div className="pos-verdict-text">
                            <div className="pos-verdict-title">
                              Close Now = LOSS of {fmt.usd(Math.abs(pnl))} ({pnlPct.toFixed(1)}%)
                            </div>
                            <div className="pos-verdict-sub">
                              {isSold
                                ? <>You sold at <b>{fmt.usd(perShareCost)}/sh</b> but it's now <b>{fmt.usd(currentPerShare)}/sh</b> — it went up against you. Buying to close costs more than you received.</>
                                : <>You bought at <b>{fmt.usd(perShareCost)}/sh</b> but it's now <b>{fmt.usd(currentPerShare)}/sh</b> — it lost value from time decay and/or wrong direction.</>
                              }
                            </div>
                          </div>
                          <div className="pos-close-pnl-badge" style={{ background: "rgba(239,68,68,0.2)", color: "var(--accent-red)", fontSize: 20, fontWeight: 800, padding: "8px 16px" }}>
                            {fmt.usd(pnl)}
                          </div>
                        </div>
                      ) : (
                        <div className="pos-verdict pos-verdict-breakeven">
                          <div className="pos-verdict-icon">⚖️</div>
                          <div className="pos-verdict-text">
                            <div className="pos-verdict-title">Close Now = BREAKEVEN</div>
                            <div className="pos-verdict-sub">Current value equals your entry price. No profit, no loss.</div>
                          </div>
                          <div className="pos-close-pnl-badge" style={{ background: "rgba(245,158,11,0.2)", color: "var(--accent-amber)", fontSize: 20, fontWeight: 800, padding: "8px 16px" }}>
                            $0
                          </div>
                        </div>
                      )}

                      {/* ── Stats grid ── */}
                      <div className="pos-close-grid">
                        <div className="pos-close-stat">
                          <div className="pos-close-stat-value" style={{ color: "var(--accent-cyan)" }}>
                            {fmt.usd(perShareCost)}/sh
                          </div>
                          <div className="pos-close-stat-label">{isSold ? "Sold At (Entry)" : "Bought At (Entry)"}</div>
                        </div>
                        <div className="pos-close-stat">
                          <div className="pos-close-stat-value" style={{ color: "var(--accent-blue)" }}>
                            {fmt.usd(currentPerShare)}/sh
                          </div>
                          <div className="pos-close-stat-label">Current Market Price</div>
                        </div>
                        <div className="pos-close-stat">
                          <div className="pos-close-stat-value" style={{
                            color: pnl >= 0 ? "var(--accent-green)" : "var(--accent-red)"
                          }}>
                            {fmt.sign(pnl)}
                          </div>
                          <div className="pos-close-stat-label">
                            {pnl >= 0 ? "Profit if Closed Now" : "Loss if Closed Now"}
                          </div>
                        </div>
                        <div className="pos-close-stat">
                          <div className="pos-close-stat-value" style={{
                            color: daysToExp != null && daysToExp <= 7 ? "var(--accent-red)"
                              : daysToExp != null && daysToExp <= 21 ? "var(--accent-amber)"
                              : "var(--text-primary)"
                          }}>
                            {daysToExp != null ? `${daysToExp}d` : "—"}
                          </div>
                          <div className="pos-close-stat-label">Days to Expiration</div>
                        </div>
                      </div>

                      {/* ══ RECOVERY STRATEGIES (only for losing positions) ══ */}
                      {pnl < 0 && (() => {
                        const underlying = p.contract.underlying || sym.replace(/\d.*/,"") || sym;
                        const lossPctAbs = totalPremium > 0 ? (Math.abs(pnl) / totalPremium * 100) : 0;
                        const breakEvenPrice = isSold
                          ? (type === "put" ? p.contract.strike - perShareCost : p.contract.strike + perShareCost)
                          : (type === "call" ? p.contract.strike + perShareCost : p.contract.strike - perShareCost);

                        // ── Roll calculation helpers ──
                        const rollStrikeDiff = 5; // $5 strike shift for Down/Up rolls
                        // Use the next standard monthly expiration (3rd Friday) at least 21 days out,
                        // and strictly AFTER the current position's expiration
                        const newExpDate = nextMonthlyExpiration(21, expDate);
                        const newDTECalc = Math.ceil((newExpDate.getTime() - Date.now()) / (1000 * 60 * 60 * 24));
                        const mult = p.contract.multiplier || 100;
                        const posDelta = p.greeks?.delta; // use actual Greek if available

                        // Roll Out: same strike, later exp
                        const rollOutEstPrice = roundTick(
                          estimateRolledPrice(currentPerShare, daysToExp, newDTECalc, 0, posDelta),
                          underlying
                        );
                        // Roll Shift: shifted strike, later exp
                        const rollShiftEstPrice = roundTick(
                          estimateRolledPrice(currentPerShare, daysToExp, newDTECalc, rollStrikeDiff, posDelta),
                          underlying
                        );

                        // ── Live IBKR NBBO override (when available) ──
                        const rightChar = type === "call" ? "C" : "P";
                        const shiftedStrikeCalc = type === "put"
                          ? p.contract.strike - rollStrikeDiff
                          : p.contract.strike + rollStrikeDiff;
                        const rollOutNBBOKey = `${underlying}-${rightChar}-${p.contract.strike}-${newExpDate.getTime()}`;
                        const rollShiftNBBOKey = `${underlying}-${rightChar}-${shiftedStrikeCalc}-${newExpDate.getTime()}`;
                        const rollOutLive = liveNBBO[rollOutNBBOKey];
                        const rollShiftLive = liveNBBO[rollShiftNBBOKey];

                        // "isLive" = got real data from IBKR (could be real-time or delayed)
                        const rollOutHasData = rollOutLive && rollOutLive !== "loading" && rollOutLive !== "error" && rollOutLive.mid > 0;
                        const rollShiftHasData = rollShiftLive && rollShiftLive !== "loading" && rollShiftLive !== "error" && rollShiftLive.mid > 0;
                        const rollOutIsLive = rollOutHasData;
                        const rollShiftIsLive = rollShiftHasData;
                        const rollOutIsDelayed = rollOutHasData && rollOutLive.delayed;
                        const rollShiftIsDelayed = rollShiftHasData && rollShiftLive.delayed;
                        const rollOutLoading = rollOutLive === "loading";
                        const rollShiftLoading = rollShiftLive === "loading";

                        const rollOutNewPrice = rollOutIsLive
                          ? roundTick(rollOutLive.mid, underlying)
                          : rollOutEstPrice;
                        const rollShiftNewPrice = rollShiftIsLive
                          ? roundTick(rollShiftLive.mid, underlying)
                          : rollShiftEstPrice;

                        const rollOutPriceLabel = rollOutIsLive ? (rollOutIsDelayed ? "IBKR delayed" : "IBKR live") : rollOutLoading ? "loading…" : "est.";
                        const rollShiftPriceLabel = rollShiftIsLive ? (rollShiftIsDelayed ? "IBKR delayed" : "IBKR live") : rollShiftLoading ? "loading…" : "est.";

                        const rollOutNetCredit = isSold
                          ? (rollOutNewPrice - currentPerShare)
                          : (currentPerShare - rollOutNewPrice);
                        const rollOutNetPnL = rollOutNetCredit * Math.abs(p.quantity) * mult;

                        // Roll Down & Out (put) / Roll Up & Out (call): shifted strike, later exp
                        const shiftedStrike = type === "put"
                          ? p.contract.strike - rollStrikeDiff
                          : p.contract.strike + rollStrikeDiff;

                        const rollShiftNetCredit = isSold
                          ? (rollShiftNewPrice - currentPerShare)
                          : (currentPerShare - rollShiftNewPrice);
                        const rollShiftNetPnL = rollShiftNetCredit * Math.abs(p.quantity) * mult;

                        const newExpStr = newExpDate.toLocaleDateString("en-US", {
                          weekday: "short", month: "short", day: "numeric", year: "2-digit",
                        });
                        // Use local-timezone YYYYMMDD everywhere — NOT .toISOString() which shifts to UTC
                        const newExpIBKR = `${newExpDate.getFullYear()}${String(newExpDate.getMonth()+1).padStart(2,"0")}${String(newExpDate.getDate()).padStart(2,"0")}`;

                        const recoveryOptions = [];

                        if (isSold) {
                          // Short option at a loss — it went against us
                          recoveryOptions.push({
                            name: "Roll Out (in time)",
                            tag: "Common", tagColor: "var(--accent-green)", tagBg: "rgba(16,185,129,0.15)",
                            desc: `Buy to close the current ${type} (exp ${currentExpStr}) and sell a new ${type} at the SAME strike ($${p.contract.strike}) but with a LATER expiration. Target: ${newExpStr} (${newDTECalc}d, IBKR: ${newExpIBKR}).`,
                            steps: [
                              `BUY to Close: ${underlying} ${type.toUpperCase()} $${p.contract.strike} exp **${currentExpStr}** (${currentExpIBKR}) @ ~${fmt.usd(currentPerShare)}/sh (current market)`,
                              `SELL to Open: ${underlying} ${type.toUpperCase()} $${p.contract.strike} exp **${newExpStr}** (${newExpIBKR}) @ **${fmt.usd(rollOutNewPrice)}**/sh (${rollOutPriceLabel})`,
                              `Expiration: **${currentExpStr}** → **${newExpStr}** — standard monthly (3rd Friday), ${newDTECalc} DTE`,
                              `Net ${rollOutNetCredit >= 0 ? "credit" : "debit"}: ${fmtSignUsd(rollOutNetCredit)}/sh × ${Math.abs(p.quantity)} contracts = ${fmtSignUsd(rollOutNetPnL)}`,
                              rollOutIsLive ? `✅ Price from IBKR ${rollOutIsDelayed ? "delayed" : "real-time"} NBBO (bid $${rollOutLive.bid} / ask $${rollOutLive.ask})` : `⚠️ Price is a theoretical estimate — click Execute to use IBKR real-time NBBO`,
                            ],
                            canProfit: true,
                            rollLegs: [
                              {
                                symbol: underlying, type: type, strike: p.contract.strike,
                                expiration: currentExpIBKR, side: "buy",
                                quantity: Math.abs(p.quantity),
                                price: roundTick(currentPerShare, underlying),
                                exchange: p.contract.exchange || "SMART",
                              },
                              {
                                symbol: underlying, type: type, strike: p.contract.strike,
                                expiration: newExpIBKR, side: "sell",
                                quantity: Math.abs(p.quantity),
                                price: rollOutNewPrice,
                                exchange: p.contract.exchange || "SMART",
                              },
                            ],
                            netCredit: rollOutNetCredit,
                            netPnL: rollOutNetPnL,
                            newStrike: p.contract.strike,
                            newExp: newExpStr,
                            newExpIBKR: newExpIBKR,
                            newDTE: newDTECalc,
                            newPrice: rollOutNewPrice,
                            isLive: rollOutIsLive,
                            isDelayed: rollOutIsDelayed,
                            isLoading: rollOutLoading,
                            liveBid: rollOutIsLive ? rollOutLive.bid : null,
                            liveAsk: rollOutIsLive ? rollOutLive.ask : null,
                          });
                          if (type === "put") {
                            recoveryOptions.push({
                              name: "Roll Down & Out",
                              tag: "Defensive", tagColor: "var(--accent-cyan)", tagBg: "rgba(6,182,212,0.15)",
                              desc: `Buy to close the current put ($${p.contract.strike}, exp ${currentExpStr}) and sell a new put at a LOWER strike ($${shiftedStrike}) with exp ${newExpStr} (${newExpIBKR}). Reduces risk by moving the strike further from the current price.`,
                              steps: [
                                `BUY to Close: ${underlying} PUT $${p.contract.strike} exp **${currentExpStr}** (${currentExpIBKR}) @ ~${fmt.usd(currentPerShare)}/sh (current market)`,
                                `SELL to Open: ${underlying} PUT $${shiftedStrike} exp **${newExpStr}** (${newExpIBKR}) @ **${fmt.usd(rollShiftNewPrice)}**/sh (${rollShiftPriceLabel})`,
                                `Expiration: **${currentExpStr}** → **${newExpStr}** — standard monthly (3rd Friday), ${newDTECalc} DTE`,
                                `Net ${rollShiftNetCredit >= 0 ? "credit" : "debit"}: ${fmtSignUsd(rollShiftNetCredit)}/sh × ${Math.abs(p.quantity)} contracts = ${fmtSignUsd(rollShiftNetPnL)}`,
                                `New strike $${shiftedStrike} gives more safety margin`,
                                rollShiftIsLive ? `✅ Price from IBKR ${rollShiftIsDelayed ? "delayed" : "real-time"} NBBO (bid $${rollShiftLive.bid} / ask $${rollShiftLive.ask})` : `⚠️ Price is a theoretical estimate — click Execute to use IBKR real-time NBBO`,
                              ],
                              canProfit: true,
                              rollLegs: [
                                {
                                  symbol: underlying, type: "put", strike: p.contract.strike,
                                  expiration: currentExpIBKR, side: "buy",
                                  quantity: Math.abs(p.quantity),
                                  price: roundTick(currentPerShare, underlying),
                                  exchange: p.contract.exchange || "SMART",
                                },
                                {
                                  symbol: underlying, type: "put", strike: shiftedStrike,
                                  expiration: newExpIBKR, side: "sell",
                                  quantity: Math.abs(p.quantity),
                                  price: rollShiftNewPrice,
                                  exchange: p.contract.exchange || "SMART",
                                },
                              ],
                              netCredit: rollShiftNetCredit,
                              netPnL: rollShiftNetPnL,
                              newStrike: shiftedStrike,
                              newExp: newExpStr,
                              newExpIBKR: newExpIBKR,
                              newDTE: newDTECalc,
                              newPrice: rollShiftNewPrice,
                              isLive: rollShiftIsLive,
                              isDelayed: rollShiftIsDelayed,
                              isLoading: rollShiftLoading,
                              liveBid: rollShiftIsLive ? rollShiftLive.bid : null,
                              liveAsk: rollShiftIsLive ? rollShiftLive.ask : null,
                            });
                          } else {
                            recoveryOptions.push({
                              name: "Roll Up & Out",
                              tag: "Defensive", tagColor: "var(--accent-cyan)", tagBg: "rgba(6,182,212,0.15)",
                              desc: `Buy to close the current call ($${p.contract.strike}, exp ${currentExpStr}) and sell a new call at a HIGHER strike ($${shiftedStrike}) with exp ${newExpStr} (${newExpIBKR}). Moves the strike further above current price.`,
                              steps: [
                                `BUY to Close: ${underlying} CALL $${p.contract.strike} exp **${currentExpStr}** (${currentExpIBKR}) @ ~${fmt.usd(currentPerShare)}/sh (current market)`,
                                `SELL to Open: ${underlying} CALL $${shiftedStrike} exp **${newExpStr}** (${newExpIBKR}) @ **${fmt.usd(rollShiftNewPrice)}**/sh (${rollShiftPriceLabel})`,
                                `Expiration: **${currentExpStr}** → **${newExpStr}** — standard monthly (3rd Friday), ${newDTECalc} DTE`,
                                `Net ${rollShiftNetCredit >= 0 ? "credit" : "debit"}: ${fmtSignUsd(rollShiftNetCredit)}/sh × ${Math.abs(p.quantity)} contracts = ${fmtSignUsd(rollShiftNetPnL)}`,
                                `New strike $${shiftedStrike} gives more safety margin`,
                                rollShiftIsLive ? `✅ Price from IBKR ${rollShiftIsDelayed ? "delayed" : "real-time"} NBBO (bid $${rollShiftLive.bid} / ask $${rollShiftLive.ask})` : `⚠️ Price is a theoretical estimate — click Execute to use IBKR real-time NBBO`,
                              ],
                              canProfit: true,
                              rollLegs: [
                                {
                                  symbol: underlying, type: "call", strike: p.contract.strike,
                                  expiration: currentExpIBKR, side: "buy",
                                  quantity: Math.abs(p.quantity),
                                  price: roundTick(currentPerShare, underlying),
                                  exchange: p.contract.exchange || "SMART",
                                },
                                {
                                  symbol: underlying, type: "call", strike: shiftedStrike,
                                  expiration: newExpIBKR, side: "sell",
                                  quantity: Math.abs(p.quantity),
                                  price: rollShiftNewPrice,
                                  exchange: p.contract.exchange || "SMART",
                                },
                              ],
                              netCredit: rollShiftNetCredit,
                              netPnL: rollShiftNetPnL,
                              newStrike: shiftedStrike,
                              newExp: newExpStr,
                              newExpIBKR: newExpIBKR,
                              newDTE: newDTECalc,
                              newPrice: rollShiftNewPrice,
                              isLive: rollShiftIsLive,
                              isDelayed: rollShiftIsDelayed,
                              isLoading: rollShiftLoading,
                              liveBid: rollShiftIsLive ? rollShiftLive.bid : null,
                              liveAsk: rollShiftIsLive ? rollShiftLive.ask : null,
                            });
                          }
                          recoveryOptions.push({
                            name: "Close & Accept Loss",
                            tag: "Safest", tagColor: "var(--accent-amber)", tagBg: "rgba(245,158,11,0.15)",
                            desc: `Sometimes the best move is to cut losses. Close the position (exp ${currentExpStr}) now and free up capital for better opportunities. Loss: ${fmt.usd(Math.abs(pnl))}.`,
                            steps: [
                              `${closeVerb} ${Math.abs(p.quantity)}x ${underlying} ${type.toUpperCase()} $${p.contract.strike} exp **${currentExpStr}** (${currentExpIBKR}) at ~${fmt.usd(currentPerShare)}/sh`,
                              `Total cost to close: ~${fmt.usd(Math.abs(p.marketValue))}`,
                              `Realized loss: ${fmt.usd(Math.abs(pnl))}`,
                              `Capital freed up for new trades`,
                            ],
                            canProfit: false,
                            rollLegs: null,
                          });
                        } else {
                          // Long option at a loss — value dropped
                          if (daysToExp != null && daysToExp > 14) {
                            recoveryOptions.push({
                              name: "Hold & Wait",
                              tag: "If thesis intact", tagColor: "var(--accent-blue)", tagBg: "rgba(59,130,246,0.15)",
                              desc: `You still have ${daysToExp} days until expiration. If your original thesis (${type === "call" ? `${underlying} will go above $${breakEvenPrice.toFixed(0)}` : `${underlying} will go below $${breakEvenPrice.toFixed(0)}`}) is still valid, holding may make sense.`,
                              steps: [
                                `Current breakeven: ${underlying} needs to reach $${breakEvenPrice.toFixed(2)} by expiration`,
                                `Time value remaining: ${daysToExp} days — theta will accelerate under 21 days`,
                                `Monitor daily — set a mental stop loss (e.g., close if loss exceeds ${fmt.usd(totalPremium * 0.7)})`,
                              ],
                              canProfit: true,
                              rollLegs: null,
                            });
                          }
                          recoveryOptions.push({
                            name: "Roll to Later Expiration",
                            tag: "Common", tagColor: "var(--accent-green)", tagBg: "rgba(16,185,129,0.15)",
                            desc: `Sell your current ${type} (exp ${currentExpStr}) and buy a new one at the same strike ($${p.contract.strike}) but with more time. Target: ${newExpStr} (${newExpIBKR}).`,
                            steps: [
                              `SELL to Close: ${underlying} ${type.toUpperCase()} $${p.contract.strike} exp **${currentExpStr}** (${currentExpIBKR}) @ ~${fmt.usd(currentPerShare)}/sh (current market)`,
                              `BUY to Open: ${underlying} ${type.toUpperCase()} $${p.contract.strike} exp **${newExpStr}** (${newExpIBKR}) @ **${fmt.usd(rollOutNewPrice)}**/sh (${rollOutPriceLabel})`,
                              `Expiration: **${currentExpStr}** → **${newExpStr}** — standard monthly (3rd Friday), ${newDTECalc} DTE`,
                              `Net ${rollOutNetCredit >= 0 ? "credit" : "debit"}: ${fmtSignUsd(rollOutNetCredit)}/sh × ${Math.abs(p.quantity)} contracts = ${fmtSignUsd(rollOutNetPnL)}`,
                              `${rollOutNetPnL < 0 ? "Additional cost to roll: " + fmt.usd(Math.abs(rollOutNetPnL)) + " — but buys more time" : "Net credit from the roll"}`,
                              rollOutIsLive ? `✅ Price from IBKR ${rollOutIsDelayed ? "delayed" : "real-time"} NBBO (bid $${rollOutLive.bid} / ask $${rollOutLive.ask})` : `⚠️ Price is a theoretical estimate — click Execute to use IBKR real-time NBBO`,
                            ],
                            canProfit: true,
                            rollLegs: [
                              {
                                symbol: underlying, type: type, strike: p.contract.strike,
                                expiration: currentExpIBKR, side: "sell",
                                quantity: Math.abs(p.quantity),
                                price: roundTick(currentPerShare, underlying),
                                exchange: p.contract.exchange || "SMART",
                              },
                              {
                                symbol: underlying, type: type, strike: p.contract.strike,
                                expiration: newExpIBKR, side: "buy",
                                quantity: Math.abs(p.quantity),
                                price: rollOutNewPrice,
                                exchange: p.contract.exchange || "SMART",
                              },
                            ],
                            netCredit: rollOutNetCredit,
                            netPnL: rollOutNetPnL,
                            newStrike: p.contract.strike,
                            newExp: newExpStr,
                            newExpIBKR: newExpIBKR,
                            newDTE: newDTECalc,
                            newPrice: rollOutNewPrice,
                            isLive: rollOutIsLive,
                            isDelayed: rollOutIsDelayed,
                            isLoading: rollOutLoading,
                            liveBid: rollOutIsLive ? rollOutLive.bid : null,
                            liveAsk: rollOutIsLive ? rollOutLive.ask : null,
                          });
                          recoveryOptions.push({
                            name: "Sell a Spread (Reduce Cost)",
                            tag: "Advanced", tagColor: "var(--accent-purple)", tagBg: "rgba(139,92,246,0.15)",
                            desc: `Turn your losing ${type} into a ${type === "call" ? "bull call" : "bear put"} spread by selling a further-OTM ${type}. This collects premium to reduce your cost basis, but caps your max profit.`,
                            steps: [
                              `Keep: ${underlying} ${type.toUpperCase()} $${p.contract.strike} (your current position)`,
                              `Sell to Open: ${underlying} ${type.toUpperCase()} $${type === "call" ? (p.contract.strike + 10).toFixed(0) : (p.contract.strike - 10).toFixed(0)} (same expiration)`,
                              `Premium received reduces your total cost`,
                              `Max profit is now capped at the spread width minus net cost`,
                            ],
                            canProfit: true,
                            rollLegs: null,
                          });
                          recoveryOptions.push({
                            name: "Close & Accept Loss",
                            tag: lossPctAbs > 50 ? "Recommended" : "Safest",
                            tagColor: lossPctAbs > 50 ? "var(--accent-red)" : "var(--accent-amber)",
                            tagBg: lossPctAbs > 50 ? "rgba(239,68,68,0.15)" : "rgba(245,158,11,0.15)",
                            desc: lossPctAbs > 50
                              ? `Down ${lossPctAbs.toFixed(0)}% — most of the premium is gone. Close now to salvage the remaining ${fmt.usd(Math.abs(p.marketValue))} before theta eats the rest.`
                              : `Close at current loss of ${fmt.usd(Math.abs(pnl))} and reallocate capital. Sometimes cutting a small loss prevents a bigger one.`,
                            steps: [
                              `${closeVerb} ${Math.abs(p.quantity)}x ${underlying} ${type.toUpperCase()} $${p.contract.strike} exp **${currentExpStr}** (${currentExpIBKR}) at ~${fmt.usd(currentPerShare)}/sh`,
                              `You'll recover: ~${fmt.usd(Math.abs(p.marketValue))}`,
                              `Realized loss: ${fmt.usd(Math.abs(pnl))}`,
                            ],
                            canProfit: false,
                            rollLegs: null,
                          });
                        }

                        const lossRec = getActionRecommendation(pnl, totalPremium || 0, -(totalPremium || Math.abs(pnl) * 2), daysToExp);
                        return (
                          <div className="pos-recovery">
                            <div className="pos-recovery-title" style={{ display: "flex", alignItems: "center", gap: 8 }}>
                              <span style={{ fontSize: 16 }}>🔄</span>
                              What Can You Do? — Recovery Options
                              <span style={{
                                marginLeft: "auto", display: "inline-flex", alignItems: "center", gap: 4,
                                padding: "3px 8px", borderRadius: 6, fontSize: 10, fontWeight: 700,
                                background: `${lossRec.color}22`, color: lossRec.color, border: `1px solid ${lossRec.color}44`,
                              }}>⭐ {lossRec.tag}: {lossRec.reason}</span>
                            </div>
                            {recoveryOptions.map((opt, oi) => {
                              const isCloseAction = opt.name === "Close & Accept Loss";
                              const hasRollLegs = !!opt.rollLegs;
                              // For Close & Accept Loss: single close leg
                              const closingLegs = isCloseAction ? [{
                                symbol: underlying,
                                type: type,
                                strike: p.contract.strike,
                                expiration: currentExpIBKR, // YYYYMMDD — avoids timezone serialization risk
                                side: p.quantity < 0 ? "buy" : "sell",
                                quantity: Math.abs(p.quantity),
                                price: roundTick(currentPerShare, underlying),
                                exchange: p.contract.exchange || "SMART",
                              }] : opt.rollLegs;
                              const canExecute = isCloseAction || hasRollLegs;

                              return (
                              <div key={oi} className="pos-recovery-option" style={{
                                borderLeftColor: opt.canProfit ? "var(--accent-green)" : "var(--accent-amber)",
                              }}>
                                <div className="pos-recovery-option-header">
                                  <div className="pos-recovery-option-name">
                                    <span>{opt.canProfit ? "🟢" : "🟡"}</span>
                                    {opt.name}
                                  </div>
                                  <span className="pos-recovery-option-tag" style={{
                                    background: opt.tagBg, color: opt.tagColor,
                                  }}>
                                    {opt.tag}
                                  </span>
                                </div>
                                <div className="pos-recovery-option-desc">{opt.desc}</div>
                                <div className="pos-recovery-option-steps">
                                  {opt.steps.map((step, si) => (
                                    <div key={si} className="pos-recovery-step">
                                      <span className="pos-recovery-step-bullet">→</span>
                                      <span dangerouslySetInnerHTML={{ __html: step.replace(/\*\*(.*?)\*\*/g, "<b>$1</b>") }} />
                                    </div>
                                  ))}
                                </div>

                                {/* ── P&L Summary for roll strategies ── */}
                                {hasRollLegs && opt.netPnL != null && (
                                  <div style={{
                                    marginTop: 8, padding: "10px 12px", borderRadius: 6,
                                    background: opt.netPnL >= 0 ? "rgba(16,185,129,0.08)" : "rgba(239,68,68,0.08)",
                                    border: `1px solid ${opt.netPnL >= 0 ? "rgba(16,185,129,0.2)" : "rgba(239,68,68,0.2)"}`,
                                  }}>
                                    <div style={{ display: "flex", justifyContent: "space-between", alignItems: "center", flexWrap: "wrap", gap: 8, marginBottom: 6 }}>
                                      <div style={{ display: "flex", gap: 16, fontSize: 12, flexWrap: "wrap" }}>
                                        <div>
                                          <span style={{ color: "var(--text-muted)" }}>New Strike: </span>
                                          <span style={{ fontWeight: 700 }}>${opt.newStrike}</span>
                                        </div>
                                        <div>
                                          <span style={{ color: "var(--text-muted)" }}>Current Exp: </span>
                                          <span style={{ fontWeight: 700, fontFamily: "monospace" }}>{currentExpIBKR}</span>
                                          <span style={{ color: "var(--text-muted)", marginLeft: 2 }}>({currentExpStr})</span>
                                        </div>
                                        <div>
                                          <span style={{ color: "var(--text-muted)" }}>→ New Exp: </span>
                                          <span style={{ fontWeight: 700 }}>{opt.newExp}</span>
                                          <span style={{ color: "var(--text-muted)", marginLeft: 2 }}>({opt.newExpIBKR})</span>
                                        </div>
                                        <div>
                                          <span style={{ color: "var(--text-muted)" }}>Price: </span>
                                          <span style={{ fontWeight: 700 }}>{fmt.usd(opt.newPrice)}/sh</span>
                                          {opt.isLive && !opt.isDelayed && (
                                            <span style={{
                                              marginLeft: 4, fontSize: 9, padding: "1px 5px", borderRadius: 3,
                                              background: "rgba(16,185,129,0.2)", color: "var(--accent-green)", fontWeight: 700,
                                            }}>LIVE</span>
                                          )}
                                          {opt.isLive && opt.isDelayed && (
                                            <span style={{
                                              marginLeft: 4, fontSize: 9, padding: "1px 5px", borderRadius: 3,
                                              background: "rgba(59,130,246,0.2)", color: "var(--accent-blue)", fontWeight: 700,
                                            }}>DELAYED</span>
                                          )}
                                          {opt.isLoading && (
                                            <span style={{
                                              marginLeft: 4, fontSize: 9, padding: "1px 5px", borderRadius: 3,
                                              background: "rgba(245,158,11,0.2)", color: "var(--accent-amber)", fontWeight: 600,
                                              animation: "pulse 1s infinite",
                                            }}>loading…</span>
                                          )}
                                        </div>
                                        {opt.isLive && opt.liveBid != null && (
                                          <div>
                                            <span style={{ color: "var(--text-muted)" }}>Bid/Ask: </span>
                                            <span style={{ fontWeight: 700 }}>${opt.liveBid} / ${opt.liveAsk}</span>
                                          </div>
                                        )}
                                      </div>
                                      <div style={{
                                        padding: "4px 12px", borderRadius: 6, fontWeight: 800, fontSize: 14,
                                        background: opt.netPnL >= 0 ? "rgba(16,185,129,0.15)" : "rgba(239,68,68,0.15)",
                                        color: opt.netPnL >= 0 ? "var(--accent-green)" : "var(--accent-red)",
                                      }}>
                                        {opt.netPnL >= 0 ? "Credit" : "Debit"}: {fmtSignUsd(opt.netPnL)}
                                      </div>
                                    </div>
                                    <div style={{ fontSize: 10, color: "var(--text-muted)", fontStyle: "italic" }}>
                                      {opt.isLive
                                        ? (opt.isDelayed
                                          ? `🕐 Delayed IBKR price (market closed). Actual execution will use real-time NBBO. ${opt.newDTE || "?"} DTE.`
                                          : `✅ Live IBKR NBBO snapshot. New position: ${opt.newDTE || "?"} DTE.`)
                                        : `💡 Price is a theoretical estimate (sqrt time + delta). Actual execution at IBKR real-time NBBO mid-price.${opt.newDTE ? ` New position: ${opt.newDTE} DTE.` : ""}`
                                      }
                                    </div>
                                  </div>
                                )}

                                {/* ── Auto-execute button via modal ── */}
                                {canExecute && closingLegs && (
                                  <div style={{ marginTop: 8, paddingTop: 8, borderTop: "1px solid rgba(30,41,59,0.5)" }}>
                                    <button style={{
                                      padding: "8px 16px", fontSize: 12, fontWeight: 700,
                                      background: hasRollLegs ? "rgba(59,130,246,0.15)" : "rgba(239,68,68,0.15)",
                                      color: hasRollLegs ? "var(--accent-blue)" : "var(--accent-red)",
                                      border: `1px solid ${hasRollLegs ? "rgba(59,130,246,0.3)" : "rgba(239,68,68,0.3)"}`,
                                      borderRadius: 6, cursor: "pointer", width: "100%",
                                    }} onClick={(e) => {
                                      e.stopPropagation();
                                      openActionModal({
                                        name: hasRollLegs ? `Roll ${opt.name}` : opt.name,
                                        strategyName: `${underlying} ${type.toUpperCase()} $${p.contract.strike}`,
                                        legs: closingLegs,
                                        estimatedPnL: hasRollLegs && opt.netPnL != null ? opt.netPnL : pnl,
                                        reason: opt.desc,
                                        recommended: opt.tag === "Recommended",
                                        tag: opt.tag,
                                        tagColor: opt.tagColor,
                                      });
                                    }}>
                                      {hasRollLegs ? (
                                        <>⚡ Execute Roll: {currentExpIBKR} → {opt.newExpIBKR} {opt.newStrike !== p.contract.strike ? `$${p.contract.strike}→$${opt.newStrike}` : `$${opt.newStrike}`} {opt.netPnL != null ? `(est. ${opt.netPnL >= 0 ? "credit" : "debit"} ${fmt.usd(Math.abs(opt.netPnL))})` : ""}</>
                                      ) : (
                                        <>⚡ Execute: {closeVerb} {Math.abs(p.quantity)}x exp {currentExpIBKR} @ {fmt.usd(roundTick(currentPerShare, underlying))}/sh via IBKR</>
                                      )}
                                    </button>
                                  </div>
                                )}
                              </div>
                              );
                            })}
                          </div>
                        );
                      })()}

                      {/* ── Profit position — Smart Action Cards ── */}
                      {pnl > 0 && (() => {
                        const underlying = p.contract.underlying || sym.replace(/\d.*/,"") || sym;
                        const maxProfit = totalPremium || Math.abs(pnl) * 2; // estimate
                        const maxLoss = -(totalPremium || Math.abs(pnl) * 2);
                        const rec = getActionRecommendation(pnl, maxProfit, maxLoss, daysToExp);

                        const baseClosingLegs = [{
                          symbol: underlying,
                          type: type,
                          strike: p.contract.strike,
                          expiration: currentExpIBKR,
                          side: p.quantity < 0 ? "buy" : "sell",
                          quantity: Math.abs(p.quantity),
                          price: roundTick(currentPerShare, underlying),
                          exchange: p.contract.exchange || "SMART",
                        }];

                        // Define available actions
                        const actions = [];

                        // 1. Take Profit (Close All)
                        actions.push({
                          id: "take-profit",
                          icon: "💰",
                          name: "Take Profit — Close All",
                          desc: `Lock in ${fmt.usd(pnl)} profit (${Math.abs(pnlPct).toFixed(0)}% of premium). Many pros close at 50-75%.`,
                          color: "#10b981",
                          executable: true,
                          legs: baseClosingLegs,
                          estimatedPnL: pnl,
                        });

                        // 2. Hold
                        actions.push({
                          id: "hold",
                          icon: "⏳",
                          name: isSold ? "Hold & Let Theta Decay" : "Hold & Let It Run",
                          desc: isSold
                            ? "Keep the position to capture remaining premium. Risk: underlying could reverse."
                            : "Let the position continue — more upside potential. Risk: time decay + reversal.",
                          color: "#3b82f6",
                          executable: false,
                        });

                        // 3. Partial close (if qty >= 2)
                        if (Math.abs(p.quantity) >= 2) {
                          const halfQty = Math.ceil(Math.abs(p.quantity) / 2);
                          actions.push({
                            id: "partial",
                            icon: "✂️",
                            name: `Partial Close — ${halfQty} of ${Math.abs(p.quantity)}`,
                            desc: `Close ${halfQty} contracts to lock in partial profit. Let the rest run.`,
                            color: "#8b5cf6",
                            executable: true,
                            legs: [{
                              ...baseClosingLegs[0],
                              quantity: halfQty,
                            }],
                            estimatedPnL: pnl * (halfQty / Math.abs(p.quantity)),
                          });
                        }

                        // Warning for near expiration
                        const expiryWarning = daysToExp != null && daysToExp <= 7
                          ? `⚠️ Only ${daysToExp} days left — gamma risk high near expiration.`
                          : daysToExp != null && daysToExp <= 21
                          ? `⚠️ ${daysToExp} days left — theta decay accelerating.`
                          : null;

                        return (
                        <div className="pos-close-recommendation pos-rec-profit" style={{ flexDirection: "column", alignItems: "flex-start", gap: 10 }}>
                          <div style={{ display: "flex", alignItems: "center", gap: 8, width: "100%" }}>
                            <span style={{ fontSize: 16 }}>💰</span>
                            <b>You're in profit — Smart Actions:</b>
                            <span style={{
                              marginLeft: "auto", display: "inline-flex", alignItems: "center", gap: 4,
                              padding: "3px 8px", borderRadius: 6, fontSize: 10, fontWeight: 700,
                              background: `${rec.color}22`, color: rec.color, border: `1px solid ${rec.color}44`,
                            }}>⭐ {rec.tag}</span>
                          </div>
                          {expiryWarning && (
                            <div style={{ fontSize: 11, color: "var(--accent-amber)", fontWeight: 600, width: "100%" }}>
                              {expiryWarning}
                            </div>
                          )}
                          <div style={{ display: "flex", flexDirection: "column", gap: 6, width: "100%" }}>
                            {actions.map(act => {
                              const isRecommended = (
                                (rec.action === "close" && act.id === "take-profit") ||
                                (rec.action === "hold" && act.id === "hold") ||
                                (rec.action === "roll" && act.id === "partial")
                              );
                              return (
                                <div key={act.id} style={{
                                  display: "flex", alignItems: "center", gap: 10, padding: "8px 12px",
                                  borderRadius: 8, cursor: act.executable ? "pointer" : "default",
                                  background: isRecommended ? `${act.color}15` : "rgba(255,255,255,0.03)",
                                  border: isRecommended ? `2px solid ${act.color}55` : "1px solid rgba(255,255,255,0.06)",
                                  transition: "all 0.15s",
                                }} onClick={(e) => e.stopPropagation()}>
                                  <span style={{ fontSize: 18 }}>{act.icon}</span>
                                  <div style={{ flex: 1, minWidth: 0 }}>
                                    <div style={{ fontWeight: 700, fontSize: 12, color: act.color }}>
                                      {act.name}
                                      {isRecommended && <span style={{ marginLeft: 6, fontSize: 10, opacity: 0.8 }}>⭐ Recommended</span>}
                                    </div>
                                    <div style={{ fontSize: 11, color: "var(--text-secondary)", marginTop: 2 }}>{act.desc}</div>
                                  </div>
                                  {act.executable && (
                                    <button style={{
                                      padding: "6px 12px", fontSize: 11, fontWeight: 700, whiteSpace: "nowrap",
                                      background: `${act.color}22`, color: act.color,
                                      border: `1px solid ${act.color}44`, borderRadius: 6, cursor: "pointer",
                                    }} onClick={(e) => {
                                      e.stopPropagation();
                                      openActionModal({
                                        name: act.name,
                                        strategyName: `${sym} ${type.toUpperCase()} $${p.contract.strike}`,
                                        legs: act.legs,
                                        estimatedPnL: act.estimatedPnL,
                                        reason: act.desc,
                                        recommended: isRecommended,
                                        tag: isRecommended ? rec.tag : null,
                                        tagColor: act.color,
                                      });
                                    }}>
                                      ⚡ Execute
                                    </button>
                                  )}
                                </div>
                              );
                            })}
                          </div>
                        </div>
                        );
                      })()}

                      {/* ── How to close ── */}
                      <div className="pos-close-how">
                        <div className="pos-close-how-title">
                          <span style={{ fontSize: 14 }}>🔧</span>
                          How to {closeVerb} in IBKR TWS
                        </div>
                        <div className="pos-close-step">
                          <div className="pos-close-step-num">1</div>
                          <div>
                            In TWS, find <b>{sym}</b> {type.toUpperCase()} <b>${p.contract.strike}</b>{" "}
                            exp <b>{currentExpStr}</b> ({currentExpIBKR})
                          </div>
                        </div>
                        <div className="pos-close-step">
                          <div className="pos-close-step-num">2</div>
                          <div>
                            Right-click → <b>Close Position</b> (or <b>Trade</b> → select <b>{closeAction}</b>)
                          </div>
                        </div>
                        <div className="pos-close-step">
                          <div className="pos-close-step-num">3</div>
                          <div>
                            Set Quantity: <b>{Math.abs(p.quantity)}</b> contracts
                          </div>
                        </div>
                        <div className="pos-close-step">
                          <div className="pos-close-step-num">4</div>
                          <div>
                            Order Type: <b>LMT</b> — Limit Price: <b>{fmt.usd(roundTick(currentPerShare, p.contract.underlying || sym))}</b>/sh
                            <span style={{ color: "var(--text-muted)", marginLeft: 4 }}>
                              (midpoint — adjust for fill)
                            </span>
                          </div>
                        </div>
                        <div className="pos-close-step">
                          <div className="pos-close-step-num">5</div>
                          <div>
                            TIF: <b>DAY</b> — Review all fields and click <b>Transmit</b>
                          </div>
                        </div>
                      </div>

                      {/* Action buttons: manual details + copy + auto-execute */}
                      <div className="pos-close-actions" style={{ flexWrap: "wrap" }}>
                        <button className="btn-manual" onClick={(e) => {
                          e.stopPropagation();
                          setShowCloseManual(showCloseManual === i ? null : i);
                        }}>
                          {showCloseManual === i ? "Hide Details" : "📋 Full Contract Details"}
                        </button>
                        <button className="manual-copy-btn" style={{ padding: "8px 14px", fontSize: 12 }} onClick={(e) => {
                          e.stopPropagation();
                          const underlying = p.contract.underlying || sym.replace(/\d.*/,"") || sym;
                          const expIBKR = currentExpIBKR;
                          const text = [
                            `Action: ${closeAction}`,
                            `Quantity: ${Math.abs(p.quantity)}`,
                            `Symbol: ${underlying}`,
                            `Sec Type: OPT`,
                            `Right: ${type === "call" ? "CALL (C)" : "PUT (P)"}`,
                            `Strike: $${p.contract.strike}`,
                            `Expiration: ${expIBKR}`,
                            `Multiplier: ${mult}`,
                            `Exchange: SMART`,
                            `Order Type: LMT`,
                            `Limit Price: $${roundTick(currentPerShare, p.contract.underlying || sym).toFixed(2)}`,
                            `TIF: DAY`,
                          ].join("\n");
                          navigator.clipboard.writeText(text);
                        }}>
                          Copy All
                        </button>

                        {/* ── Auto-execute close button via modal ── */}
                        {(() => {
                          const closingLegs = [{
                            symbol: p.contract.underlying || sym.replace(/\d.*/,"") || sym,
                            type: type,
                            strike: p.contract.strike,
                            expiration: currentExpIBKR,
                            side: p.quantity < 0 ? "buy" : "sell",
                            quantity: Math.abs(p.quantity),
                            price: roundTick(currentPerShare, p.contract.underlying || sym),
                            exchange: p.contract.exchange || "SMART",
                          }];
                          return (
                            <button style={{
                              padding: "8px 14px", fontSize: 12, fontWeight: 700,
                              background: pnl >= 0 ? "rgba(16,185,129,0.15)" : "rgba(239,68,68,0.15)",
                              color: pnl >= 0 ? "var(--accent-green)" : "var(--accent-red)",
                              border: `1px solid ${pnl >= 0 ? "rgba(16,185,129,0.3)" : "rgba(239,68,68,0.3)"}`,
                              borderRadius: 6, cursor: "pointer",
                            }} onClick={(e) => {
                              e.stopPropagation();
                              openActionModal({
                                name: `${closeVerb} Position`,
                                strategyName: `${sym} ${type.toUpperCase()} $${p.contract.strike}`,
                                legs: closingLegs,
                                estimatedPnL: pnl,
                                reason: pnl >= 0 ? "Close to lock in profit" : "Close to cut losses",
                                recommended: false,
                                tag: pnl >= 0 ? "TAKE PROFIT" : "CUT LOSS",
                                tagColor: pnl >= 0 ? "#10b981" : "#ef4444",
                              });
                            }}>
                              ⚡ {closeVerb} exp {currentExpIBKR} via IBKR
                            </button>
                          );
                        })()}
                      </div>

                      {/* Full manual details */}
                      {showCloseManual === i && (
                        <div style={{ marginTop: 12 }}>
                          <ManualLegPanel
                            legs={[{
                              side: closeAction.toLowerCase(),
                              quantity: Math.abs(p.quantity),
                              symbol: p.contract.underlying || sym,
                              type: type,
                              strike: p.contract.strike,
                              expiration: currentExpIBKR, // YYYYMMDD — avoids timezone serialization risk
                              price: roundTick(currentPerShare, p.contract.underlying || sym),
                            }]}
                            strategyName={`Close ${sym}`}
                          />
                        </div>
                      )}
                    </div>
                  </td>
                </tr>
              )}
            </React.Fragment>
          );
        })}
      </tbody>
    </table>

    {/* ── Action Confirmation Modal ── */}
    {confirmAction && (
      <ActionConfirmModal
        action={confirmAction}
        onConfirm={async (legs) => {
          const result = await submitCloseOrder(legs);
          return result;
        }}
        onCancel={() => setConfirmAction(null)}
      />
    )}
    </>
  );
}

function StressTestChart({ stressTests }) {
  if (!stressTests?.length) return null;
  const maxAbs = Math.max(...stressTests.map((s) => Math.abs(s.portfolioPnL)));
  return (
    <div>
      {stressTests.map((s, i) => {
        const isLoss = s.portfolioPnL < 0;
        const width = Math.max((Math.abs(s.portfolioPnL) / maxAbs) * 100, 5);
        return (
          <div key={i} className="stress-bar-container">
            <div className="stress-label">
              <span>{s.scenario}</span>
              <span className={isLoss ? "negative" : "positive"}>{fmt.sign(s.portfolioPnL)}</span>
            </div>
            <div className="stress-bar" style={{
              width: width + "%",
              background: isLoss
                ? `rgba(239,68,68,${0.2 + (width / 100) * 0.4})`
                : `rgba(16,185,129,${0.2 + (width / 100) * 0.4})`,
              color: isLoss ? "var(--accent-red)" : "var(--accent-green)",
            }}>
              {fmt.usd(Math.abs(s.portfolioPnL))}
            </div>
          </div>
        );
      })}
    </div>
  );
}

function FactorBars({ factors }) {
  if (!factors?.length) return null;
  const sorted = [...factors].sort((a, b) => Math.abs(b.contribution) - Math.abs(a.contribution));
  return (
    <div>
      {sorted.slice(0, 6).map((f, i) => {
        const isPositive = f.contribution >= 0;
        const maxC = Math.max(...factors.map((x) => Math.abs(x.contribution)), 1);
        const width = (Math.abs(f.contribution) / maxC) * 100;
        return (
          <div key={i} className="factor-bar">
            <div className="factor-bar-label">
              <span style={{ color: "var(--text-secondary)" }}>{f.name}</span>
              <span className={isPositive ? "positive" : "negative"}>
                {isPositive ? "+" : ""}{f.contribution.toFixed(1)}
              </span>
            </div>
            <div className="factor-bar-track">
              <div className="factor-bar-fill" style={{
                width: width + "%",
                background: isPositive ? "var(--accent-green)" : "var(--accent-red)",
              }} />
            </div>
          </div>
        );
      })}
    </div>
  );
}

// ── Reusable manual entry panel for any strategy with legs ──
function ManualLegPanel({ legs, strategyName }) {
  return (
    <div className="manual-panel" onClick={(e) => e.stopPropagation()}>
      <div className="manual-panel-title">
        <span style={{ fontSize: 16 }}>📋</span>
        Manual Order Entry — Enter these in IBKR TWS
      </div>
      {legs.map((leg, li) => {
        const isOption = leg.type === "call" || leg.type === "put";
        const underlying = leg.underlying || leg.symbol || (strategyName || "").split(" ").find(w => /^[A-Z]{1,5}$/.test(w)) || "???";
        const expDate = parseExpDate(leg.expiration);
        const expStr = expDate
          ? expDate.toLocaleDateString("en-US", { weekday: "short", month: "short", day: "numeric", year: "2-digit" })
          : "—";
        const expIBKR = expDate
          ? `${expDate.getFullYear()}${String(expDate.getMonth()+1).padStart(2,"0")}${String(expDate.getDate()).padStart(2,"0")}`
          : "—";

        const fields = [
          { label: "Action", value: leg.side.toUpperCase(), highlight: leg.side === "buy" ? "var(--accent-green)" : "var(--accent-red)" },
          { label: "Quantity", value: String(leg.quantity) },
          { label: "Symbol", value: underlying },
          { label: "Sec Type", value: isOption ? "OPT" : "STK" },
        ];
        if (isOption) {
          fields.push(
            { label: "Right", value: leg.type === "call" ? "CALL (C)" : "PUT (P)" },
            { label: "Strike", value: `$${leg.strike}` },
            { label: "Expiration", value: `${expStr}  (IBKR: ${expIBKR})` },
            { label: "Multiplier", value: "100" },
          );
        }
        fields.push(
          { label: "Exchange", value: "SMART" },
          { label: "Order Type", value: "LMT" },
          { label: "Limit Price", value: leg.price != null ? `$${roundTick(Number(leg.price), underlying).toFixed(2)}` : "MKT" },
          { label: "TIF", value: "DAY" },
        );

        const copyText = fields.map(f => `${f.label}: ${f.value}`).join("\n");

        return (
          <div key={li} className={`manual-leg manual-leg-${leg.side}`}>
            <div className="manual-leg-title">
              <span style={{ color: leg.side === "buy" ? "var(--accent-green)" : "var(--accent-red)" }}>
                {leg.side === "buy" ? "▲" : "▼"}
              </span>
              Leg {li + 1}: {leg.side.toUpperCase()} {leg.quantity}x {isOption ? `${underlying} ${leg.type.toUpperCase()} $${leg.strike}` : underlying}
              <button className="manual-copy-btn" onClick={() => { navigator.clipboard.writeText(copyText); }}>
                Copy
              </button>
            </div>
            {fields.map((f, fi) => (
              <div key={fi} className="manual-field">
                <span className="manual-field-label">{f.label}</span>
                <span className="manual-field-value" style={f.highlight ? { color: f.highlight } : {}}>
                  {f.value}
                </span>
              </div>
            ))}
          </div>
        );
      })}
      <div style={{ marginTop: 10, fontSize: 11, color: "var(--text-muted)", lineHeight: 1.5 }}>
        <b>Steps in IBKR TWS:</b> Open TWS → right-click symbol → Trade → New Order →
        enter each leg as shown above → verify all fields → Transmit.
        <br/>
        <b>Note:</b> Expirations and strikes shown are from the AI analysis.
        Verify they exist in TWS Option Chain before placing.
      </div>
    </div>
  );
}

function MarketAnalysisPanel({ technical, price }) {
  if (!technical) return null;
  const trendIcon = technical.trend === "bullish" ? "📈" : technical.trend === "bearish" ? "📉" : "➡️";
  const trendColor = technical.trend === "bullish" ? "var(--accent-green)" : technical.trend === "bearish" ? "var(--accent-red)" : "var(--accent-amber)";
  const bullishCount = (technical.signals || []).filter(s => s.direction === "bullish").length;
  const bearishCount = (technical.signals || []).filter(s => s.direction === "bearish").length;
  const totalSignals = (technical.signals || []).length;

  const rsiColor = technical.rsi14 > 70 ? "var(--accent-red)" : technical.rsi14 < 30 ? "var(--accent-green)" : "var(--text-primary)";
  const rsiLabel = technical.rsi14 > 70 ? "Overbought" : technical.rsi14 < 30 ? "Oversold" : technical.rsi14 > 60 ? "Bullish" : technical.rsi14 < 40 ? "Bearish" : "Neutral";

  return (
    <div style={{ background: "var(--surface)", border: "1px solid var(--border)", borderRadius: 10, padding: 16, marginBottom: 16 }}>
      <div style={{ display: "flex", alignItems: "center", gap: 10, marginBottom: 12 }}>
        <span style={{ fontSize: 18 }}>{trendIcon}</span>
        <span style={{ color: trendColor, fontWeight: 700, fontSize: 15, textTransform: "uppercase" }}>{technical.trend} Trend</span>
        <div style={{ background: "var(--bg)", borderRadius: 6, height: 8, flex: 1, overflow: "hidden" }}>
          <div style={{ height: "100%", width: `${technical.trendStrength || 50}%`, background: trendColor, borderRadius: 6, transition: "width 0.4s ease" }} />
        </div>
        <span style={{ fontSize: 11, color: "var(--text-muted)", fontWeight: 600 }}>{(technical.trendStrength || 50).toFixed(0)}%</span>
        <span style={{ fontSize: 11, color: "var(--text-muted)", marginLeft: 8 }}>{bullishCount}/{totalSignals} bullish</span>
      </div>

      {/* Indicators grid */}
      <div style={{ display: "grid", gridTemplateColumns: "repeat(4, 1fr)", gap: 10, marginBottom: 12 }}>
        <div style={{ background: "var(--bg)", borderRadius: 8, padding: "8px 10px" }}>
          <div style={{ fontSize: 10, color: "var(--text-muted)", marginBottom: 3 }}>RSI(14)</div>
          <div style={{ fontSize: 16, fontWeight: 700, color: rsiColor }}>{technical.rsi14.toFixed(1)}</div>
          <div style={{ fontSize: 10, color: rsiColor }}>{rsiLabel}</div>
        </div>
        <div style={{ background: "var(--bg)", borderRadius: 8, padding: "8px 10px" }}>
          <div style={{ fontSize: 10, color: "var(--text-muted)", marginBottom: 3 }}>SMA(20)</div>
          <div style={{ fontSize: 16, fontWeight: 700, color: price > technical.sma20 ? "var(--accent-green)" : "var(--accent-red)" }}>${technical.sma20.toFixed(2)}</div>
          <div style={{ fontSize: 10, color: price > technical.sma20 ? "var(--accent-green)" : "var(--accent-red)" }}>{price > technical.sma20 ? "Above ↑" : "Below ↓"}</div>
        </div>
        <div style={{ background: "var(--bg)", borderRadius: 8, padding: "8px 10px" }}>
          <div style={{ fontSize: 10, color: "var(--text-muted)", marginBottom: 3 }}>SMA(50)</div>
          <div style={{ fontSize: 16, fontWeight: 700, color: price > technical.sma50 ? "var(--accent-green)" : "var(--accent-red)" }}>${technical.sma50.toFixed(2)}</div>
          <div style={{ fontSize: 10, color: price > technical.sma50 ? "var(--accent-green)" : "var(--accent-red)" }}>{price > technical.sma50 ? "Above ↑" : "Below ↓"}</div>
        </div>
        <div style={{ background: "var(--bg)", borderRadius: 8, padding: "8px 10px" }}>
          <div style={{ fontSize: 10, color: "var(--text-muted)", marginBottom: 3 }}>MACD</div>
          <div style={{ fontSize: 16, fontWeight: 700, color: technical.macdHistogram > 0 ? "var(--accent-green)" : "var(--accent-red)" }}>{technical.macdHistogram > 0 ? "+" : ""}{technical.macdHistogram.toFixed(3)}</div>
          <div style={{ fontSize: 10, color: technical.macdHistogram > 0 ? "var(--accent-green)" : "var(--accent-red)" }}>{technical.macdHistogram > 0 ? "Bullish" : "Bearish"}</div>
        </div>
      </div>

      {/* Support / Resistance levels */}
      <div style={{ display: "flex", gap: 16, flexWrap: "wrap" }}>
        {technical.supports && technical.supports.length > 0 && (
          <div style={{ display: "flex", alignItems: "center", gap: 6 }}>
            <span style={{ fontSize: 10, color: "var(--text-muted)" }}>Support:</span>
            {technical.supports.slice(0, 3).map((s, i) => (
              <span key={i} style={{ background: "rgba(16,185,129,0.12)", color: "var(--accent-green)", fontSize: 11, fontWeight: 600, padding: "2px 8px", borderRadius: 4 }}>${s.toFixed(2)}</span>
            ))}
          </div>
        )}
        {technical.resistances && technical.resistances.length > 0 && (
          <div style={{ display: "flex", alignItems: "center", gap: 6 }}>
            <span style={{ fontSize: 10, color: "var(--text-muted)" }}>Resistance:</span>
            {technical.resistances.slice(0, 3).map((r, i) => (
              <span key={i} style={{ background: "rgba(239,68,68,0.12)", color: "var(--accent-red)", fontSize: 11, fontWeight: 600, padding: "2px 8px", borderRadius: 4 }}>${r.toFixed(2)}</span>
            ))}
          </div>
        )}
      </div>

      {/* Signals summary */}
      {technical.signals && technical.signals.length > 0 && (
        <div style={{ marginTop: 10, display: "flex", flexWrap: "wrap", gap: 6 }}>
          {technical.signals.map((sig, i) => {
            const sigColor = sig.direction === "bullish" ? "var(--accent-green)" : sig.direction === "bearish" ? "var(--accent-red)" : "var(--text-muted)";
            const sigBg = sig.direction === "bullish" ? "rgba(16,185,129,0.08)" : sig.direction === "bearish" ? "rgba(239,68,68,0.08)" : "rgba(148,163,184,0.06)";
            const sigIcon = sig.direction === "bullish" ? "▲" : sig.direction === "bearish" ? "▼" : "●";
            return (
              <div key={i} title={sig.reasoning} style={{ background: sigBg, border: `1px solid ${sigColor}22`, borderRadius: 6, padding: "3px 8px", fontSize: 10, color: sigColor, cursor: "help", display: "flex", alignItems: "center", gap: 4 }}>
                <span style={{ fontSize: 8 }}>{sigIcon}</span>
                {sig.name}: {sig.value}
              </div>
            );
          })}
        </div>
      )}
    </div>
  );
}

function StrategyCard({ strategy, index, selected, onSelect, onApprove }) {
  const [showManual, setShowManual] = useState(false);
  const s = strategy;
  const capitalPct = s.capitalPct || 0;
  const riskPct = s.riskPct || 0;
  const barColor = capitalPct > 50 ? "var(--accent-red)" : capitalPct > 25 ? "var(--accent-amber)" : "var(--accent-green)";
  // Compute nearest expiration from legs
  const legExps = (s.legs || [])
    .map((l) => l.expiration)
    .filter(Boolean)
    .map((e) => new Date(e))
    .filter((d) => !isNaN(d.getTime()));
  const nearestExp = legExps.length > 0
    ? new Date(Math.min(...legExps.map((d) => d.getTime())))
    : null;

  return (
    <div className={`strategy-card ${selected ? "selected" : ""}`} onClick={() => onSelect(index)}>
      <div className="strategy-header">
        <div>
          <div className="strategy-name">{s.name}</div>
          {nearestExp && (() => {
            const now = new Date();
            const daysLeft = Math.ceil((nearestExp - now) / (1000 * 60 * 60 * 24));
            const dateStr = nearestExp.toLocaleDateString("en-US", { weekday: "short", month: "short", day: "numeric", year: "2-digit" });
            const color = daysLeft <= 7 ? "var(--accent-red)"
              : daysLeft <= 21 ? "var(--accent-amber)"
              : "var(--text-muted)";
            return (
              <div style={{ fontSize: 11, color, marginTop: 3, display: "flex", alignItems: "center", gap: 6 }}>
                <span style={{ opacity: 0.6 }}>Exp:</span> {dateStr}
                <span style={{
                  background: daysLeft <= 7 ? "rgba(239,68,68,0.15)" : daysLeft <= 21 ? "rgba(245,158,11,0.12)" : "rgba(148,163,184,0.1)",
                  padding: "1px 6px", borderRadius: 4, fontSize: 10, fontWeight: 600,
                }}>{daysLeft > 0 ? `${daysLeft}d` : "Expired"}</span>
              </div>
            );
          })()}
        </div>
        <div style={{ display: "flex", gap: 8, alignItems: "center" }}>
          <div style={{
            fontSize: 11, padding: "3px 8px", borderRadius: 6, fontWeight: 600,
            background: riskPct > 2 ? "rgba(239,68,68,0.15)" : "rgba(16,185,129,0.15)",
            color: riskPct > 2 ? "var(--accent-red)" : "var(--accent-green)",
          }}>
            Risk: {riskPct.toFixed(1)}%
          </div>
          <div className="strategy-score">{s.score.toFixed(0)}</div>
        </div>
      </div>
      <div className="strategy-details">
        <div>
          <div className="strategy-detail-label">Max Profit</div>
          <div className="strategy-detail-value positive">
            {s.maxProfit === "unlimited" ? "Unlimited" : fmt.usd(s.maxProfit)}
          </div>
        </div>
        <div>
          <div className="strategy-detail-label">Max Loss</div>
          <div className="strategy-detail-value negative">{fmt.usd(s.maxLoss)}</div>
        </div>
        <div>
          <div className="strategy-detail-label">
            Net Debit
            <span className="info-icon">
              i
              <span className="info-tooltip">
                <strong style={{color: "var(--text-primary)"}}>Credit</strong> = you receive premium upfront. The sold options are worth more than the bought ones.<br/><br/>
                <strong style={{color: "var(--text-primary)"}}>Debit</strong> = you pay premium upfront. The bought options cost more than the sold ones.
              </span>
            </span>
          </div>
          <div className="strategy-detail-value" style={{ color: s.netDebit < 0 ? "var(--accent-green)" : "var(--accent-amber)" }}>
            {s.netDebit < 0 ? "Credit " : "Debit "}{fmt.usd(Math.abs(s.netDebit))}
          </div>
        </div>
        <div>
          <div className="strategy-detail-label">Capital Req</div>
          <div className="strategy-detail-value">{fmt.usd(s.requiredCapital)}</div>
        </div>
      </div>
      {/* Capital usage bar */}
      <div className="capital-bar-wrapper">
        <div className="capital-bar-label">
          <span>Capital usage</span>
          <span style={{ color: barColor, fontWeight: 600 }}>{capitalPct.toFixed(1)}% of available</span>
        </div>
        <div className="capital-bar-track">
          <div className="capital-bar-fill" style={{ width: Math.min(capitalPct, 100) + "%", background: barColor }} />
        </div>
      </div>
      <div className="legs">
        {s.legs.map((leg, li) => (
          <div key={li} className={`leg-badge ${leg.side === "buy" ? "leg-buy" : "leg-sell"}`}>
            {leg.side.toUpperCase()} {leg.quantity}x {leg.type.toUpperCase()} ${leg.strike}
          </div>
        ))}
      </div>
      {/* Strategy Explanation */}
      {s.explanation && s.explanation !== s.name && (
        <div style={{ background: "var(--bg)", borderRadius: 8, padding: "8px 12px", marginTop: 8, fontSize: 11, lineHeight: 1.5 }}>
          {s.explanation.split("\n").map((line, li) => {
            const color = line.includes("✅") ? "var(--accent-green)"
              : line.includes("⚠️") ? "var(--accent-amber)"
              : line.includes("📈") ? "var(--accent-green)"
              : line.includes("📉") ? "var(--accent-red)"
              : line.includes("➡️") ? "var(--accent-amber)"
              : "var(--text-muted)";
            return <div key={li} style={{ color, marginBottom: 2 }}>{line}</div>;
          })}
        </div>
      )}
      {selected && (
        <div>
          {s.factors?.length > 0 && (
            <div style={{ marginTop: 16 }}>
              <div className="card-title">SHAP Factor Attribution</div>
              <FactorBars factors={s.factors} />
            </div>
          )}
          <div style={{ display: "flex", gap: 10, alignItems: "center" }}>
            <button
              className="btn-approve"
              onClick={(e) => { e.stopPropagation(); onApprove(index); }}
              disabled={s.approved}
              style={s.approved ? { background: "rgba(16,185,129,0.2)", color: "var(--accent-green)", cursor: "default" } : {}}
            >
              {s.approved ? "✓ Approved — See Orders Tab" : "Approve (Auto)"}
            </button>
            <button
              className="btn-manual"
              onClick={(e) => { e.stopPropagation(); setShowManual(!showManual); }}
            >
              {showManual ? "Hide Manual Details" : "📋 Manual Entry"}
            </button>
          </div>
          {!s.approved && !showManual && (
            <div className="risk-warning">
              Human-in-the-loop required. Review all factors before approving.
              <b>Auto</b> submits to IBKR automatically. <b>Manual Entry</b> shows contract details for manual TWS entry.
            </div>
          )}
          {s.approved && (
            <div style={{
              background: "rgba(16,185,129,0.08)", border: "1px solid rgba(16,185,129,0.2)",
              borderRadius: 8, padding: "10px 14px", fontSize: 12, color: "var(--accent-green)",
              marginTop: 8, display: "flex", alignItems: "center", gap: 8,
            }}>
              <span style={{ fontSize: 16 }}>✓</span>
              Order approved and recorded. Check the Orders tab for status and details.
            </div>
          )}
          {showManual && (
            <ManualLegPanel legs={s.legs} strategyName={s.name} />
          )}
        </div>
      )}
    </div>
  );
}

function PayoffChart({ strategies, selectedIdx, market }) {
  const s = strategies[selectedIdx];
  if (!s) return <div className="loading" style={{ fontSize: 12 }}>Select a strategy to see payoff</div>;

  const currentPrice = market?.price || 0;

  // Generate payoff data from strategy
  const legs = s.legs || [];
  const strikes = legs.map((l) => l.strike);
  const minStrike = Math.min(...strikes);
  const maxStrike = Math.max(...strikes);
  const range = Math.max(maxStrike - minStrike, 20);
  const center = (minStrike + maxStrike) / 2;

  const points = [];
  for (let price = center - range * 1.5; price <= center + range * 1.5; price += range / 25) {
    let pnl = 0;
    for (const leg of legs) {
      const dir = leg.side === "buy" ? 1 : -1;
      const intrinsic = leg.type === "call"
        ? Math.max(price - leg.strike, 0)
        : Math.max(leg.strike - price, 0);
      pnl += (intrinsic - (leg.price || 0)) * dir * (leg.quantity || 1) * 100;
    }
    points.push({ price: Math.round(price * 100) / 100, pnl: Math.round(pnl) });
  }

  // Compute P&L at current price for the marker
  let pnlAtCurrent = 0;
  if (currentPrice > 0) {
    for (const leg of legs) {
      const dir = leg.side === "buy" ? 1 : -1;
      const intrinsic = leg.type === "call"
        ? Math.max(currentPrice - leg.strike, 0)
        : Math.max(leg.strike - currentPrice, 0);
      pnlAtCurrent += (intrinsic - (leg.price || 0)) * dir * (leg.quantity || 1) * 100;
    }
    pnlAtCurrent = Math.round(pnlAtCurrent);
  }

  // Breakeven
  const breakevens = [];
  for (let i = 1; i < points.length; i++) {
    if ((points[i - 1].pnl <= 0 && points[i].pnl >= 0) || (points[i - 1].pnl >= 0 && points[i].pnl <= 0)) {
      breakevens.push(points[i].price);
    }
  }

  return (
    <div>
      {currentPrice > 0 && (
        <div style={{ display: "flex", gap: 12, fontSize: 10, color: "var(--text-muted)", marginBottom: 6, flexWrap: "wrap" }}>
          <span>Price: <b style={{ color: "var(--accent-amber)" }}>${currentPrice.toFixed(2)}</b>{market?.delayed && <span style={{ color: "#f59e0b", fontSize: 9, marginLeft: 4, padding: "1px 4px", background: "rgba(245,158,11,0.15)", borderRadius: 3 }}>DELAYED</span>}</span>
          <span>P&L at Price: <b style={{ color: pnlAtCurrent >= 0 ? "var(--accent-green)" : "var(--accent-red)" }}>{pnlAtCurrent >= 0 ? "+$" : "-$"}{Math.abs(pnlAtCurrent)}</b></span>
          <span>Max Profit: <b style={{ color: "var(--accent-green)" }}>+${s.maxProfit}</b></span>
          <span>Max Loss: <b style={{ color: "var(--accent-red)" }}>-${Math.abs(s.maxLoss)}</b></span>
          {breakevens.map((be, i) => (
            <span key={i}>BE: <b style={{ color: "var(--accent-amber)" }}>${be}</b></span>
          ))}
        </div>
      )}
      <ResponsiveContainer width="100%" height={220}>
        <AreaChart data={points} margin={{ top: 10, right: 10, left: 10, bottom: 0 }}>
          <defs>
            <linearGradient id="profitGrad" x1="0" y1="0" x2="0" y2="1">
              <stop offset="0%" stopColor="#10b981" stopOpacity={0.3} />
              <stop offset="100%" stopColor="#10b981" stopOpacity={0} />
            </linearGradient>
          </defs>
          <CartesianGrid strokeDasharray="3 3" stroke="#1e293b" />
          <XAxis dataKey="price" tick={{ fill: "#64748b", fontSize: 10 }} tickFormatter={(v) => "$" + v} />
          <YAxis tick={{ fill: "#64748b", fontSize: 10 }} tickFormatter={(v) => v >= 0 ? "$" + v : "-$" + Math.abs(v)} />
          <Tooltip
            contentStyle={{ background: "#1e293b", border: "1px solid #334155", borderRadius: 8, fontSize: 12 }}
            labelFormatter={(v) => "Price: $" + v}
            formatter={(v) => [v >= 0 ? "$" + v : "-$" + Math.abs(v), "P&L"]}
          />
          <ReferenceLine y={0} stroke="#475569" strokeDasharray="4 4" />
          {/* P&L area */}
          <Area type="monotone" dataKey="pnl" stroke="#3b82f6" strokeWidth={2} fill="url(#profitGrad)" />
          {/* Current price marker — on top of Area */}
          {currentPrice > 0 && (
            <ReferenceLine x={Math.round(currentPrice * 100) / 100} stroke="#f59e0b" strokeWidth={3}
              label={{ value: `📍 $${currentPrice.toFixed(2)}${market?.delayed ? " (D)" : ""} | P&L: ${pnlAtCurrent >= 0 ? "+$" : "-$"}${Math.abs(pnlAtCurrent)}`,
                position: "top", fill: "#f59e0b", fontSize: 11, fontWeight: 700 }} />
          )}
          {/* Dot on the curve at current price */}
          {currentPrice > 0 && (() => {
            const nearest = points.reduce((best, p) => Math.abs(p.price - currentPrice) < Math.abs(best.price - currentPrice) ? p : best, points[0]);
            return <ReferenceDot x={nearest.price} y={nearest.pnl} r={6} fill="#f59e0b" stroke="#fff" strokeWidth={2} />;
          })()}
        </AreaChart>
      </ResponsiveContainer>
    </div>
  );
}

// ═══════════════════════════════════════════════════════════
//  TOAST NOTIFICATION
// ═══════════════════════════════════════════════════════════

function ToastContainer({ toasts }) {
  return (
    <div className="toast-container">
      {toasts.map((t) => (
        <div key={t.id} className={`toast toast-${t.type}`}>
          <span className="toast-icon">
            {t.type === "success" ? "✓" : t.type === "error" ? "✗" : "ℹ"}
          </span>
          <div className="toast-body">
            <div className="toast-title">{t.title}</div>
            {t.message && <div className="toast-msg">{t.message}</div>}
          </div>
        </div>
      ))}
    </div>
  );
}

// ═══════════════════════════════════════════════════════════
//  IBKR ERROR EXPLANATIONS
// ═══════════════════════════════════════════════════════════

const ibkrErrorExplanations = {
  200: {
    title: "No security definition found",
    explain: "IBKR cannot find a matching contract for the requested symbol, strike, expiration, or right (call/put). This usually means the option contract does not exist in the market.",
    fixes: [
      "The expiration date may not match a real options expiry (options expire on specific dates, usually the 3rd Friday of each month)",
      "The strike price may not exist for this symbol (not all strike increments are available)",
      "The symbol may be wrong or the option class may differ from expectations",
      "Check IBKR TWS manually: right-click the stock → Option Chain to see available contracts",
    ],
  },
  201: {
    title: "Order rejected — invalid order",
    explain: "The order parameters are invalid. IBKR could not accept the order as submitted.",
    fixes: [
      "Check the order quantity (must be > 0)",
      "Check the limit price (LMT orders must have a valid price)",
      "Verify the action (BUY/SELL) is correct for the strategy",
    ],
  },
  202: {
    title: "Order cancelled",
    explain: "The order was cancelled, either by the user or by IBKR.",
    fixes: ["Check if the order was manually cancelled in TWS", "Check if the market closed while order was pending"],
  },
  321: {
    title: "Invalid contract ID",
    explain: "IBKR could not validate the contract. The underlying symbol's contract ID was not recognized.",
    fixes: [
      "The underlying stock symbol may not be traded on US exchanges",
      "Try searching the symbol manually in IBKR TWS to confirm it exists",
      "Restart the server to clear the contract ID cache",
    ],
  },
  354: {
    title: "Requested market data not subscribed",
    explain: "Your IBKR account doesn't have a subscription for the required market data.",
    fixes: [
      "Subscribe to US Options data in IBKR Account Management → Market Data Subscriptions",
      "IBKR paper accounts may have limited data — try with a live account",
    ],
  },
  10147: {
    title: "Order size limit exceeded",
    explain: "The order quantity exceeds the maximum allowed by IBKR for this security.",
    fixes: ["Reduce the order quantity", "Check IBKR's position limits for this symbol"],
  },
};

function getErrorExplanation(code, message) {
  if (ibkrErrorExplanations[code]) return ibkrErrorExplanations[code];
  // Fallback: try to infer from the message
  const msg = (message || "").toLowerCase();
  if (msg.includes("no security definition")) return ibkrErrorExplanations[200];
  if (msg.includes("invalid contract")) return ibkrErrorExplanations[321];
  return {
    title: "IBKR Error",
    explain: message || "An unknown error occurred when submitting the order to IBKR.",
    fixes: [
      "Check the IBKR TWS log for more details",
      "Verify the symbol, strike, and expiration are valid",
      "Try restarting the server and IBKR TWS",
    ],
  };
}

function ErrorDetailPanel({ orders }) {
  // Collect all orders with errors
  const errorOrders = orders.filter((o) =>
    ["error", "rejected", "failed"].includes(o.status)
  );
  if (!errorOrders.length) return null;

  return (
    <div className="error-detail-panel">
      <div className="error-detail-header">
        <span style={{ fontSize: 18 }}>⚠️</span>
        <span>Order Errors — Detailed Explanation ({errorOrders.length})</span>
      </div>
      {errorOrders.map((o, i) => {
        // Parse error details from the order
        const details = o.errorDetails || [];
        // Also try to parse from the message if no details
        const msgMatch = (o.message || o.ibkrMessage || "").match(/\[(\d+)\]\s*(.*)/);
        const fallbackCode = msgMatch ? parseInt(msgMatch[1]) : 0;
        const fallbackMsg = msgMatch ? msgMatch[2] : (o.message || o.ibkrMessage || o.error || "Unknown error");

        const errorsToShow = details.length > 0
          ? details
          : [{ orderId: o.ibkrOrderIds?.[0] || 0, code: fallbackCode, message: fallbackMsg }];

        return (
          <div key={i} className="error-detail-order">
            <div style={{ display: "flex", justifyContent: "space-between", marginBottom: 8 }}>
              <span style={{ fontWeight: 700, fontSize: 13 }}>
                {o.strategyName}
              </span>
              <span style={{ fontSize: 11, color: "var(--text-muted)" }}>
                {o.symbol} — {new Date(o.timestamp).toLocaleTimeString()}
              </span>
            </div>
            {errorsToShow.map((e, j) => {
              const explanation = getErrorExplanation(e.code, e.message);
              return (
                <div key={j} style={{ marginBottom: j < errorsToShow.length - 1 ? 10 : 0 }}>
                  <div className="error-detail-code">
                    Error {e.code ? `[${e.code}]` : ""} — {explanation.title}
                    {e.orderId ? <span style={{ color: "var(--text-muted)", fontWeight: 400 }}> (IBKR #{e.orderId})</span> : null}
                  </div>
                  <div className="error-detail-msg">{e.message}</div>
                  <div className="error-detail-explain">
                    <b>What this means:</b> {explanation.explain}
                  </div>
                  {explanation.fixes && (
                    <div className="error-detail-fix">
                      <b>How to fix:</b>
                      <ul style={{ margin: "4px 0 0 16px", padding: 0 }}>
                        {explanation.fixes.map((f, k) => (
                          <li key={k} style={{ marginBottom: 2 }}>{f}</li>
                        ))}
                      </ul>
                    </div>
                  )}
                </div>
              );
            })}
          </div>
        );
      })}
    </div>
  );
}

// ═══════════════════════════════════════════════════════════
//  OPTION CHAIN TAB
// ═══════════════════════════════════════════════════════════

function OptionChainTab({ positions }) {
  const [symbol, setSymbol] = useState("");
  const [expirations, setExpirations] = useState([]);
  const [selectedExp, setSelectedExp] = useState("");
  const [chainData, setChainData] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState("");
  const [strikeRange, setStrikeRange] = useState(10);

  // Get unique symbols from portfolio for quick selection
  const portfolioSymbols = useMemo(() => {
    const syms = new Set();
    (positions || []).forEach(p => {
      const u = p.contract.underlying || p.contract.symbol;
      if (u) syms.add(u);
    });
    return Array.from(syms).sort();
  }, [positions]);

  // Get user's existing option positions for highlighting
  const userPositions = useMemo(() => {
    const map = new Map(); // "strike-right" → position
    (positions || []).forEach(p => {
      if (p.contract.type === "call" || p.contract.type === "put") {
        const u = p.contract.underlying || p.contract.symbol;
        if (u === symbol) {
          const right = p.contract.type === "call" ? "C" : "P";
          map.set(`${p.contract.strike}-${right}`, p);
        }
      }
    });
    return map;
  }, [positions, symbol]);

  // Fetch expirations when symbol changes
  const loadExpirations = async (sym) => {
    if (!sym) return;
    setError("");
    setExpirations([]);
    setSelectedExp("");
    setChainData(null);
    try {
      const res = await fetch(API + "/optionchain/" + sym + "?expiration=list");
      const json = await res.json();
      if (json.success && json.data.expirations?.length) {
        setExpirations(json.data.expirations);
        // Auto-select first expiration
        setSelectedExp(json.data.expirations[0]);
      } else {
        setError("No options available for " + sym);
      }
    } catch (e) {
      setError("Failed to load expirations: " + e.message);
    }
  };

  // Fetch chain data for selected expiration
  const loadChain = async () => {
    if (!symbol || !selectedExp) return;
    setLoading(true);
    setError("");
    setChainData(null);
    try {
      const res = await fetch(API + "/optionchain/" + symbol + "?expiration=" + selectedExp + "&range=" + strikeRange);
      const json = await res.json();
      console.log("[OptionChain] API response:", JSON.stringify(json.data?.strikes?.length), "strikes, calls:", Object.keys(json.data?.calls || {}).length, "puts:", Object.keys(json.data?.puts || {}).length);
      if (json.success) {
        setChainData(json.data);
      } else {
        setError(json.error || "Failed to load chain");
      }
    } catch (e) {
      setError("Failed to load chain: " + e.message);
    }
    setLoading(false);
  };

  // Auto-load chain when expiration changes
  useEffect(() => {
    if (symbol && selectedExp) loadChain();
  }, [selectedExp, strikeRange]);

  const fmtPrice = (v) => v != null ? "$" + v.toFixed(2) : "—";

  return (
    <div className="card">
      <div className="card-title">Option Chain — Live IBKR Prices</div>

      {/* ── Controls ── */}
      <div style={{ display: "flex", gap: 12, alignItems: "center", marginBottom: 16, flexWrap: "wrap" }}>
        {/* Symbol selector */}
        <div style={{ display: "flex", alignItems: "center", gap: 6 }}>
          <label style={{ fontSize: 12, color: "var(--text-muted)" }}>Symbol:</label>
          <select
            value={symbol}
            onChange={e => { setSymbol(e.target.value); loadExpirations(e.target.value); }}
            style={{
              background: "var(--bg-card)", color: "var(--text-primary)", border: "1px solid var(--border)",
              borderRadius: 6, padding: "6px 10px", fontSize: 13, minWidth: 100,
            }}
          >
            <option value="">Select...</option>
            {portfolioSymbols.map(s => <option key={s} value={s}>{s}</option>)}
          </select>
          <input
            type="text" placeholder="or type..."
            style={{
              background: "var(--bg-card)", color: "var(--text-primary)", border: "1px solid var(--border)",
              borderRadius: 6, padding: "6px 10px", fontSize: 13, width: 90, textTransform: "uppercase",
            }}
            onKeyDown={e => {
              if (e.key === "Enter") {
                const val = e.target.value.trim().toUpperCase();
                if (val) { setSymbol(val); loadExpirations(val); }
              }
            }}
          />
        </div>

        {/* Expiration selector */}
        {expirations.length > 0 && (
          <div style={{ display: "flex", alignItems: "center", gap: 6 }}>
            <label style={{ fontSize: 12, color: "var(--text-muted)" }}>Expiration:</label>
            <select
              value={selectedExp}
              onChange={e => setSelectedExp(e.target.value)}
              style={{
                background: "var(--bg-card)", color: "var(--text-primary)", border: "1px solid var(--border)",
                borderRadius: 6, padding: "6px 10px", fontSize: 13,
              }}
            >
              {expirations.map(exp => {
                const d = parseExpDate(exp);
                const label = d ? d.toLocaleDateString("en-US", { weekday: "short", month: "short", day: "numeric", year: "2-digit" }) : exp;
                const dte = d ? Math.ceil((d.getTime() - Date.now()) / 86400000) : "";
                return <option key={exp} value={exp}>{label} ({exp}) — {dte}d</option>;
              })}
            </select>
          </div>
        )}

        {/* Strike range */}
        <div style={{ display: "flex", alignItems: "center", gap: 6 }}>
          <label style={{ fontSize: 12, color: "var(--text-muted)" }}>Strikes ±:</label>
          <select
            value={strikeRange}
            onChange={e => setStrikeRange(parseInt(e.target.value))}
            style={{
              background: "var(--bg-card)", color: "var(--text-primary)", border: "1px solid var(--border)",
              borderRadius: 6, padding: "6px 10px", fontSize: 13,
            }}
          >
            {[5, 10, 15, 20, 25].map(n => <option key={n} value={n}>{n}</option>)}
          </select>
        </div>

        {/* Refresh button */}
        <button
          onClick={loadChain}
          disabled={loading || !symbol || !selectedExp}
          style={{
            background: loading ? "var(--border)" : "var(--accent-blue)",
            color: "#fff", border: "none", borderRadius: 6, padding: "6px 16px", fontSize: 13,
            cursor: loading ? "wait" : "pointer", fontWeight: 600,
          }}
        >
          {loading ? "Loading..." : "Refresh"}
        </button>
      </div>

      {/* ── Error ── */}
      {error && (
        <div style={{ color: "var(--accent-red)", fontSize: 13, marginBottom: 12, padding: "8px 12px",
          background: "rgba(239,68,68,0.1)", borderRadius: 6 }}>
          {error}
        </div>
      )}

      {/* ── Loading indicator ── */}
      {loading && (
        <div style={{ textAlign: "center", padding: "40px 0", color: "var(--text-muted)" }}>
          <div style={{ fontSize: 24, marginBottom: 8 }}>⏳</div>
          <div>Fetching live prices from IBKR... (~10 seconds)</div>
          <div style={{ fontSize: 11, marginTop: 4, color: "var(--text-muted)" }}>
            Requesting {strikeRange * 2 + 1} strikes × 2 (calls + puts) = {(strikeRange * 2 + 1) * 2} market data streams
          </div>
        </div>
      )}

      {/* ── Chain Table ── */}
      {chainData && !loading && (
        <div>
          <div style={{ marginBottom: 10, fontSize: 12, color: "var(--text-muted)" }}>
            {chainData.symbol} — Underlying: <b style={{ color: "var(--text-primary)" }}>{fmtPrice(chainData.underlyingPrice)}</b>
            {" | "}{chainData.strikes?.length || 0} strikes
            {" | "}Data: {Object.values(chainData.calls).filter(Boolean).length + Object.values(chainData.puts).filter(Boolean).length} options with prices
          </div>
          <div style={{ overflowX: "auto" }}>
            <table className="positions-table" style={{ width: "100%", fontSize: 12 }}>
              <thead>
                <tr>
                  <th colSpan={4} style={{ textAlign: "center", color: "var(--accent-green)", borderBottom: "2px solid var(--accent-green)", paddingBottom: 6 }}>
                    CALLS
                  </th>
                  <th style={{ textAlign: "center", borderBottom: "2px solid var(--accent-blue)", paddingBottom: 6, color: "var(--accent-blue)" }}>
                    STRIKE
                  </th>
                  <th colSpan={4} style={{ textAlign: "center", color: "var(--accent-red)", borderBottom: "2px solid var(--accent-red)", paddingBottom: 6 }}>
                    PUTS
                  </th>
                </tr>
                <tr>
                  <th style={{ textAlign: "right", fontSize: 10, color: "var(--text-muted)" }}>BID</th>
                  <th style={{ textAlign: "right", fontSize: 10, color: "var(--text-muted)" }}>ASK</th>
                  <th style={{ textAlign: "right", fontSize: 10, color: "var(--text-muted)" }}>MID</th>
                  <th style={{ textAlign: "right", fontSize: 10, color: "var(--text-muted)" }}>LAST</th>
                  <th style={{ textAlign: "center", fontSize: 10, color: "var(--text-muted)" }}></th>
                  <th style={{ textAlign: "right", fontSize: 10, color: "var(--text-muted)" }}>BID</th>
                  <th style={{ textAlign: "right", fontSize: 10, color: "var(--text-muted)" }}>ASK</th>
                  <th style={{ textAlign: "right", fontSize: 10, color: "var(--text-muted)" }}>MID</th>
                  <th style={{ textAlign: "right", fontSize: 10, color: "var(--text-muted)" }}>LAST</th>
                </tr>
              </thead>
              <tbody>
                {(chainData.strikes || []).map(strike => {
                  const c = chainData.calls[strike];
                  const p = chainData.puts[strike];
                  const isATM = chainData.underlyingPrice &&
                    Math.abs(strike - chainData.underlyingPrice) ===
                    Math.min(...chainData.strikes.map(s => Math.abs(s - chainData.underlyingPrice)));
                  const hasCallPos = userPositions.has(`${strike}-C`);
                  const hasPutPos = userPositions.has(`${strike}-P`);

                  const rowBg = isATM ? "rgba(59,130,246,0.12)" : "transparent";
                  const callBg = hasCallPos ? "rgba(16,185,129,0.15)" : "transparent";
                  const putBg = hasPutPos ? "rgba(239,68,68,0.15)" : "transparent";
                  const noDataStyle = { color: "var(--text-muted)", opacity: 0.4 };

                  return (
                    <tr key={strike} style={{ background: rowBg }}>
                      {/* Calls */}
                      <td style={{ textAlign: "right", background: callBg, ...(c ? {} : noDataStyle) }}>
                        {c ? fmtPrice(c.bid) : "—"}
                      </td>
                      <td style={{ textAlign: "right", background: callBg, fontWeight: 600, ...(c ? {} : noDataStyle) }}>
                        {c ? fmtPrice(c.ask) : "—"}
                      </td>
                      <td style={{ textAlign: "right", background: callBg, ...(c ? {} : noDataStyle) }}>
                        {c ? fmtPrice(c.mid) : "—"}
                      </td>
                      <td style={{ textAlign: "right", background: callBg, color: "var(--text-muted)", ...(c ? {} : noDataStyle) }}>
                        {c ? fmtPrice(c.last) : "—"}
                      </td>
                      {/* Strike */}
                      <td style={{
                        textAlign: "center", fontWeight: 700,
                        color: isATM ? "var(--accent-blue)" : "var(--text-primary)",
                        borderLeft: "1px solid var(--border)", borderRight: "1px solid var(--border)",
                        position: "relative",
                      }}>
                        ${strike}
                        {hasCallPos && <span style={{ position: "absolute", left: 4, color: "var(--accent-green)", fontSize: 10 }} title="You own this call">●</span>}
                        {hasPutPos && <span style={{ position: "absolute", right: 4, color: "var(--accent-red)", fontSize: 10 }} title="You own this put">●</span>}
                        {isATM && <div style={{ fontSize: 8, color: "var(--accent-blue)", fontWeight: 400 }}>ATM</div>}
                      </td>
                      {/* Puts */}
                      <td style={{ textAlign: "right", background: putBg, ...(p ? {} : noDataStyle) }}>
                        {p ? fmtPrice(p.bid) : "—"}
                      </td>
                      <td style={{ textAlign: "right", background: putBg, fontWeight: 600, ...(p ? {} : noDataStyle) }}>
                        {p ? fmtPrice(p.ask) : "—"}
                      </td>
                      <td style={{ textAlign: "right", background: putBg, ...(p ? {} : noDataStyle) }}>
                        {p ? fmtPrice(p.mid) : "—"}
                      </td>
                      <td style={{ textAlign: "right", background: putBg, color: "var(--text-muted)", ...(p ? {} : noDataStyle) }}>
                        {p ? fmtPrice(p.last) : "—"}
                      </td>
                    </tr>
                  );
                })}
              </tbody>
            </table>
          </div>
          <div style={{ fontSize: 10, color: "var(--text-muted)", marginTop: 8, display: "flex", gap: 16 }}>
            <span>🟢 = you own this call</span>
            <span>🔴 = you own this put</span>
            <span style={{ color: "var(--accent-blue)" }}>■ ATM row highlighted</span>
            <span>Prices are {Object.values(chainData.calls).find(v => v?.delayed) ? "delayed" : "real-time"} from IBKR</span>
          </div>
        </div>
      )}

      {/* ── Empty state ── */}
      {!chainData && !loading && !error && (
        <div style={{ textAlign: "center", padding: "40px 0", color: "var(--text-muted)" }}>
          Select a symbol and expiration to view the option chain
        </div>
      )}
    </div>
  );
}

// ═══════════════════════════════════════════════════════════
//  ORDERS TAB
// ═══════════════════════════════════════════════════════════

function OrdersTab({ orders }) {
  const [verifying, setVerifying] = useState(false);
  const [verifyResult, setVerifyResult] = useState(null);

  const statusLabels = {
    submitted: "Submitted to IBKR",
    filled: "Filled",
    partial_fill: "Partially Filled",
    cancelled: "Cancelled",
    rejected: "Rejected by IBKR",
    error: "Error",
    local_only: "Local Only (Demo)",
    approved: "Approved",
    failed: "Failed",
  };

  const verifyOrders = async () => {
    setVerifying(true);
    try {
      const json = await apiRawFetch("/orders/verify");
      setVerifyResult(json);
    } catch (e) {
      setVerifyResult({ success: false, error: String(e?.message || e) });
    }
    setVerifying(false);
  };

  if (!orders.length) {
    return (
      <div className="card">
        <div className="orders-empty">
          <div className="orders-empty-icon">📋</div>
          <div className="orders-empty-text">No orders yet</div>
          <div className="orders-empty-sub">
            Approve a strategy from the Analysis tab to see it here
          </div>
        </div>
      </div>
    );
  }
  return (
    <div>
      {/* Verify bar */}
      <div className="card" style={{ marginBottom: 12 }}>
        <div className="verify-bar">
          <button className="verify-btn" onClick={verifyOrders} disabled={verifying}>
            {verifying ? "⏳ Querying IBKR..." : "🔍 Verify Orders in IBKR"}
          </button>
          <span style={{ fontSize: 11, color: "var(--text-muted)" }}>
            Queries IBKR TWS for all open orders and cross-references with local orders
          </span>
        </div>

        {verifyResult && (
          <div className="verify-result">
            {!verifyResult.success ? (
              <div style={{ color: "var(--accent-red)" }}>
                {verifyResult.error || "Verification failed"}
              </div>
            ) : (
              <div>
                <div className="verify-summary">
                  <span>Local Orders: {verifyResult.data?.trackedCount ?? 0}</span>
                  <span>IBKR Open Orders: {verifyResult.data?.ibkrOpenCount ?? 0}</span>
                </div>
                {(verifyResult.data?.verification || []).map((v, i) => (
                  <div key={i} className="verify-row">
                    <span className={v.verified ? "verify-icon-ok" : "verify-icon-fail"}>
                      {v.verified ? "✅" : "❌"}
                    </span>
                    <span style={{ fontWeight: 600 }}>{v.strategyName}</span>
                    <span style={{ color: "var(--text-muted)" }}>
                      (IBKR IDs: {v.ibkrOrderIds.length > 0 ? v.ibkrOrderIds.map(id => `#${id}`).join(", ") : "none"})
                    </span>
                    <span style={{ marginLeft: "auto" }}>
                      Local: <span className={`order-status order-${v.localStatus}`} style={{ padding: "2px 6px" }}>
                        {statusLabels[v.localStatus] || v.localStatus}
                      </span>
                    </span>
                    {v.verified && v.ibkrMatches?.[0] && (
                      <span style={{ color: "var(--accent-green)", fontSize: 11 }}>
                        IBKR: {v.ibkrMatches[0].status} — {v.ibkrMatches[0].symbol}
                      </span>
                    )}
                    {!v.verified && (
                      <span style={{ color: "var(--accent-red)", fontSize: 11 }}>
                        Not found in IBKR — order may have been rejected
                      </span>
                    )}
                  </div>
                ))}
                {verifyResult.data?.allIbkrOrders?.length > 0 && (
                  <details style={{ marginTop: 10, fontSize: 11, color: "var(--text-secondary)" }}>
                    <summary style={{ cursor: "pointer", fontWeight: 600 }}>
                      All IBKR Open Orders ({verifyResult.data.allIbkrOrders.length})
                    </summary>
                    <div style={{ marginTop: 6, fontFamily: "monospace", fontSize: 10 }}>
                      {verifyResult.data.allIbkrOrders.map((o, i) => (
                        <div key={i} style={{ padding: "3px 0", borderBottom: "1px solid rgba(30,41,59,0.3)" }}>
                          #{o.orderId} — {o.action} {o.totalQuantity}x {o.symbol}
                          {o.strike ? ` ${o.strike}${o.right}` : ""} | {o.status || "open"}
                        </div>
                      ))}
                    </div>
                  </details>
                )}
              </div>
            )}
          </div>
        )}
      </div>

      {/* Error explanation panel */}
      <ErrorDetailPanel orders={orders} />

      {/* Orders table */}
      <div className="card">
        <div className="card-title">Order History ({orders.length})</div>
        <table className="table">
          <thead>
            <tr>
              <th>Time</th><th>Symbol</th><th>Strategy</th><th>Expiry</th>
              <th>Status</th><th>IBKR</th><th>Risk %</th><th>Capital</th><th>Details</th>
            </tr>
          </thead>
          <tbody>
            {[...orders].reverse().map((o, i) => (
              <tr key={i}>
                <td style={{ fontSize: 11, color: "var(--text-muted)" }}>
                  {new Date(o.timestamp).toLocaleTimeString()}
                </td>
                <td style={{ fontWeight: 600 }}>{o.symbol}</td>
                <td>
                  <span style={{ fontSize: 12 }}>{o.strategyName}</span>
                  <div style={{ fontSize: 10, color: "var(--text-muted)", marginTop: 2 }}>
                    {o.type.replace(/_/g, " ")}
                  </div>
                </td>
                <td style={{ fontSize: 12, fontWeight: 500 }}>
                  {o.expiration ? (() => {
                    const d = parseExpDate(o.expiration);
                    if (!d) return <span style={{ color: "var(--text-muted)" }}>—</span>;
                    const now = new Date();
                    const daysLeft = Math.ceil((d - now) / (1000 * 60 * 60 * 24));
                    const dateStr = d.toLocaleDateString("en-US", { month: "short", day: "numeric", year: "2-digit" });
                    const color = daysLeft <= 7 ? "var(--accent-red)"
                      : daysLeft <= 21 ? "var(--accent-amber)"
                      : "var(--text-secondary)";
                    return (
                      <div>
                        <div style={{ color }}>{dateStr}</div>
                        <div style={{ fontSize: 10, color: "var(--text-muted)" }}>
                          {daysLeft > 0 ? `${daysLeft}d left` : "Expired"}
                        </div>
                      </div>
                    );
                  })() : (
                    <span style={{ color: "var(--text-muted)" }}>—</span>
                  )}
                </td>
                <td>
                  <span className={`order-status order-${o.status}`}>
                    <span style={{ width: 6, height: 6, borderRadius: "50%", background: "currentColor", display: "inline-block" }} />
                    {statusLabels[o.status] || o.status}
                  </span>
                </td>
                <td>
                  {o.ibkrOrderIds && o.ibkrOrderIds.length > 0 ? (
                    <div className="ibkr-ids">
                      {o.ibkrOrderIds.map((id, j) => (
                        <span key={j}>#{id}{j < o.ibkrOrderIds.length - 1 ? ", " : ""}</span>
                      ))}
                    </div>
                  ) : (
                    <span style={{ fontSize: 10, color: "var(--text-muted)" }}>—</span>
                  )}
                </td>
                <td>
                  <span style={{
                    color: o.riskPct > 2 ? "var(--accent-red)" : "var(--accent-green)",
                    fontWeight: 600,
                  }}>
                    {o.riskPct != null ? o.riskPct.toFixed(2) + "%" : "—"}
                  </span>
                </td>
                <td>{fmt.usd(o.requiredCapital)}</td>
                <td style={{ fontSize: 11, maxWidth: 200 }}>
                  {o.status === "failed" || o.status === "error" || o.status === "rejected" ? (
                    <span style={{ color: "var(--accent-red)" }}>{o.error || o.ibkrMessage}</span>
                  ) : (
                    <span style={{ color: "var(--accent-green)" }}>{o.ibkrMessage || o.message || "—"}</span>
                  )}
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      </div>
    </div>
  );
}

// ═══════════════════════════════════════════════════════════
//  MAIN APP
// ═══════════════════════════════════════════════════════════

function App() {
  const [portfolio, setPortfolio] = useState(null);
  const [varData, setVarData] = useState(null);
  const [recommendations, setRecommendations] = useState(null);
  const [status, setStatus] = useState(null);
  const [loading, setLoading] = useState(true);
  const [symbol, setSymbol] = useState("AAPL");
  const [analyzing, setAnalyzing] = useState(false);
  const [selectedStrategy, setSelectedStrategy] = useState(0);
  const [activeTab, setActiveTab] = useState("portfolio");
  const [orders, setOrders] = useState([]);
  const [toasts, setToasts] = useState([]);
  const [goalsOpen, setGoalsOpen] = useState(false);
  const [goals, setGoals] = useState({
    monthlyTarget: 1000,
    maxRiskPct: 2,
    minDTE: 14,
    maxDTE: 60,
    strategies: ["bull_call_spread", "bear_put_spread", "iron_condor", "cash_secured_put"],
    symbols: ["AAPL", "MSFT", "TSLA", "SPY"],
  });
  const [newWatchlistSymbol, setNewWatchlistSymbol] = useState("");
  const [settingsSaveStatus, setSettingsSaveStatus] = useState(""); // "", "saving", "saved", "error"
  const [settingsLoaded, setSettingsLoaded] = useState(false); // prevent save before initial load
  const [portfolioPlan, setPortfolioPlan] = useState(null);
  const [scanningAll, setScanningAll] = useState(false);
  const [expandedPlanIdx, setExpandedPlanIdx] = useState(null);
  const [planManualIdx, setPlanManualIdx] = useState(null);

  const loadData = useCallback(async () => {
    setLoading(true);
    const [p, v, s] = await Promise.all([
      apiFetch("/portfolio"),
      apiFetch("/var"),
      apiFetch("/status"),
    ]);
    if (p) setPortfolio(p);
    if (v) setVarData(v);
    if (s) setStatus(s);
    setLoading(false);
  }, []);

  const analyze = useCallback(async () => {
    setAnalyzing(true);
    setSelectedStrategy(0);
    const params = new URLSearchParams({
      symbol,
      monthlyTarget: String(goals.monthlyTarget),
      maxRiskPct: String(goals.maxRiskPct),
      minDTE: String(goals.minDTE),
      maxDTE: String(goals.maxDTE),
      strategies: goals.strategies.join(","),
    });
    const r = await apiFetch(`/recommendations?${params}`);
    if (r) setRecommendations(r);
    setAnalyzing(false);
  }, [symbol, goals]);

  const scanAll = useCallback(async () => {
    if (goals.symbols.length === 0) return;
    setScanningAll(true);
    setPortfolioPlan(null);
    const params = new URLSearchParams({
      symbols: goals.symbols.join(","),
      monthlyTarget: String(goals.monthlyTarget),
      maxRiskPct: String(goals.maxRiskPct),
      minDTE: String(goals.minDTE),
      maxDTE: String(goals.maxDTE),
      strategies: goals.strategies.join(","),
    });
    const data = await apiFetch(`/portfolio-plan?${params}`);
    if (data) setPortfolioPlan(data);
    setScanningAll(false);
  }, [goals]);

  const addToast = useCallback((type, title, message) => {
    const id = Date.now();
    setToasts((prev) => [...prev, { id, type, title, message }]);
    setTimeout(() => setToasts((prev) => prev.filter((t) => t.id !== id)), 5000);
  }, []);

  const approveStrategy = useCallback(async (idx) => {
    const strat = recommendations?.strategies?.[idx];
    if (!strat) return;

    try {
      const res = await fetch(`${API}/approve/${idx}`, { method: "POST" });
      const json = await res.json();

      // Find the nearest expiration from the strategy legs
      const legExps = (strat.legs || [])
        .map((l) => l.expiration)
        .filter(Boolean)
        .map((e) => new Date(e).getTime())
        .filter((t) => !isNaN(t));
      const nearestExp = legExps.length > 0
        ? new Date(Math.min(...legExps)).toISOString()
        : null;

      const order = {
        timestamp: new Date().toISOString(),
        symbol: recommendations.symbol || symbol,
        strategyName: strat.name,
        type: strat.type,
        requiredCapital: strat.requiredCapital,
        maxProfit: strat.maxProfit,
        maxLoss: strat.maxLoss,
        legs: strat.legs,
        expiration: nearestExp,
      };

      if (json.success) {
        // Update the strategy card
        const updated = { ...recommendations };
        updated.strategies[idx].approved = true;
        setRecommendations(updated);

        // Add to orders with IBKR details
        setOrders((prev) => [...prev, {
          ...order,
          status: json.ibkrStatus || "approved",
          riskPct: json.riskPct,
          message: json.message,
          ibkrOrderIds: json.ibkrOrderIds || [],
          ibkrMessage: json.ibkrMessage || "",
          orderId: json.orderId,
        }]);

        const ibkrInfo = json.ibkrOrderIds?.length
          ? ` (IBKR #${json.ibkrOrderIds.join(", #")})`
          : " (local only)";
        addToast("success", "Strategy Approved",
          `${strat.name} — Risk: ${json.riskPct?.toFixed(2) ?? "?"}%${ibkrInfo}`);
      } else {
        // Add failed order
        setOrders((prev) => [...prev, {
          ...order,
          status: "failed",
          riskPct: json.riskPct,
          error: json.error,
          ibkrOrderIds: [],
          ibkrMessage: "",
        }]);

        addToast("error", "Approval Rejected", json.error || "Risk check failed");
      }
    } catch (e) {
      addToast("error", "Connection Error", "Failed to reach server: " + String(e));
    }
  }, [recommendations, symbol, addToast]);

  // Poll IBKR order status every 5s when there are active orders
  const pollOrderStatus = useCallback(async () => {
    if (!orders.length) return;
    const hasActive = orders.some((o) =>
      ["submitted", "partial_fill"].includes(o.status)
    );
    if (!hasActive) return;

    const data = await apiFetch("/orders");
    if (data && Array.isArray(data)) {
      setOrders((prev) =>
        prev.map((local) => {
          const server = data.find(
            (s) => s.id === local.orderId || (
              s.strategyName === local.strategyName &&
              s.submittedAt === local.timestamp
            )
          );
          if (server && (server.status !== local.status || server.errorDetails?.length)) {
            return {
              ...local,
              status: server.status,
              ibkrMessage: server.message,
              message: server.message,
              errorDetails: server.errorDetails || local.errorDetails,
            };
          }
          return local;
        })
      );
    }
  }, [orders]);

  useEffect(() => { loadData(); }, [loadData]);

  // Load saved settings on mount
  useEffect(() => {
    fetch(API + "/settings")
      .then(r => r.json())
      .then(json => {
        if (json.success && json.data) {
          setGoals(json.data);
          console.log("[Settings] Loaded from server:", JSON.stringify(json.data));
        }
      })
      .catch(err => console.warn("[Settings] Failed to load:", err))
      .finally(() => setSettingsLoaded(true));
  }, []);

  // Auto-save settings when goals change (debounced 500ms)
  useEffect(() => {
    if (!settingsLoaded) return; // Don't save before initial load completes
    const timer = setTimeout(() => {
      setSettingsSaveStatus("saving");
      fetch(API + "/settings", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(goals),
      })
        .then(r => r.json())
        .then(json => {
          if (json.success) {
            setSettingsSaveStatus("saved");
            setTimeout(() => setSettingsSaveStatus(""), 2000);
          } else {
            setSettingsSaveStatus("error");
          }
        })
        .catch(() => setSettingsSaveStatus("error"));
    }, 500);
    return () => clearTimeout(timer);
  }, [goals, settingsLoaded]);

  // Auto-refresh portfolio every 30s
  useEffect(() => {
    const interval = setInterval(loadData, 30000);
    return () => clearInterval(interval);
  }, [loadData]);

  // Poll order status every 5s
  useEffect(() => {
    const interval = setInterval(pollOrderStatus, 5000);
    return () => clearInterval(interval);
  }, [pollOrderStatus]);

  if (loading && !portfolio) {
    return (
      <div className="app">
        <div className="loading">
          <div className="spinner" />
          <div>Connecting to IBKR TWS...</div>
        </div>
      </div>
    );
  }

  const acct = portfolio?.account || {};
  const positions = portfolio?.positions || [];
  const greeks = portfolio?.greeks;
  const strategies = recommendations?.strategies || [];

  return (
    <div className="app">
      {/* Header */}
      <div className="header">
        <h1><span>Click</span> — Options Dashboard</h1>
        <div style={{ display: "flex", gap: 12, alignItems: "center" }}>
          {!status?.ibkrConnected && (
            <div className="status-badge offline">
              <div className="status-dot" />
              Demo Mode
            </div>
          )}
          <button onClick={loadData} style={{
            background: "none", border: "1px solid var(--border)", color: "var(--text-secondary)",
            padding: "6px 12px", borderRadius: 8, cursor: "pointer", fontSize: 11, fontFamily: "inherit"
          }}>Refresh</button>
        </div>
      </div>

      {/* ── Account Balance Banner ─────────────── */}
      <div className="account-banner">
        <div className="account-banner-main">
          <div style={{ display: "flex", alignItems: "center", gap: 10 }}>
            <div className="account-banner-label">Account Balance</div>
            {!status?.ibkrConnected && (
              <div className="data-source-badge data-source-demo">
                <div style={{ width: 6, height: 6, borderRadius: "50%", background: "currentColor" }} />
                Demo Data
              </div>
            )}
          </div>
          <div className="account-banner-value">{fmt.usd(acct.netLiquidation)}</div>
          <div className="account-banner-sub">
            Account {acct.accountId || "—"} &middot; {acct.currency || "USD"} &middot; Tier: {(acct.tier || "medium").toUpperCase()}
          </div>
        </div>
        <div className="account-banner-stats">
          <div className="account-stat">
            <div className="account-stat-value" style={{ color: "var(--accent-green)" }}>{fmt.usd(acct.totalCash)}</div>
            <div className="account-stat-label">Cash</div>
          </div>
          <div className="account-stat">
            <div className="account-stat-value" style={{ color: "var(--accent-cyan)" }}>{fmt.usd(acct.availableFunds)}</div>
            <div className="account-stat-label">Available for Trading</div>
          </div>
          <div className="account-stat">
            <div className="account-stat-value" style={{ color: "var(--accent-cyan)" }}>{fmt.usd(acct.buyingPower)}</div>
            <div className="account-stat-label">Buying Power</div>
          </div>
          <div className="account-stat">
            <div className="account-stat-value" style={{ color: "var(--accent-amber)" }}>{fmt.usd(acct.marginUsed)}</div>
            <div className="account-stat-label">Margin Used</div>
          </div>
          <div className="account-stat">
            <div className="account-stat-value" style={{
              color: (acct.unrealizedPnL || 0) >= 0 ? "var(--accent-green)" : "var(--accent-red)"
            }}>{fmt.sign(acct.unrealizedPnL)}</div>
            <div className="account-stat-label">Unrealized P&L</div>
          </div>
        </div>
      </div>

      {/* Toast notifications */}
      <ToastContainer toasts={toasts} />

      {/* Tabs */}
      <div className="tabs">
        {["portfolio", "analysis", "chain", "orders", "risk"].map((tab) => (
          <button key={tab} className={`tab ${activeTab === tab ? "active" : ""}`}
            onClick={() => setActiveTab(tab)}>
            {tab === "portfolio" ? "Portfolio"
              : tab === "analysis" ? "Strategy Analysis"
              : tab === "chain" ? "Option Chain"
              : tab === "orders" ? <>Orders
                  {orders.length > 0 && (
                    <span className={`tab-badge ${activeTab === "orders" ? "tab-badge-active" : "tab-badge-idle"}`}>
                      {orders.length}
                    </span>
                  )}
                </>
              : "Risk & VaR"}
          </button>
        ))}
      </div>

      {/* ── Portfolio Tab ─────────────────────────── */}
      {activeTab === "portfolio" && (
        <div>
          <div className="card" style={{ marginBottom: 16 }}>
            <div className="card-title">Portfolio Greeks (Aggregate)</div>
            <GreeksDisplay greeks={greeks} />
          </div>
          <div className="card">
            <div className="card-title">Positions ({positions.length})</div>
            <PositionsTable positions={positions} />
          </div>
        </div>
      )}

      {/* ── Analysis Tab ──────────────────────────── */}
      {activeTab === "analysis" && (
        <div>
          {/* Goals panel */}
          <div className="goals-panel">
            <div className="goals-toggle" onClick={() => setGoalsOpen(!goalsOpen)}>
              <div className="goals-toggle-title">
                <span style={{ fontSize: 16 }}>🎯</span>
                Trading Goals
                <span style={{ fontSize: 11, fontWeight: 400, color: "var(--text-muted)" }}>
                  — Target: ${goals.monthlyTarget.toLocaleString()}/mo | Risk: {goals.maxRiskPct}% | DTE: {goals.minDTE}-{goals.maxDTE}d | {goals.symbols.length} symbols
                </span>
              </div>
              {settingsSaveStatus && (
                <span style={{
                  fontSize: 10, fontWeight: 500, marginLeft: 8, padding: "2px 8px", borderRadius: 4,
                  background: settingsSaveStatus === "saved" ? "rgba(16,185,129,0.15)" :
                              settingsSaveStatus === "saving" ? "rgba(59,130,246,0.15)" :
                              "rgba(239,68,68,0.15)",
                  color: settingsSaveStatus === "saved" ? "var(--accent-green)" :
                         settingsSaveStatus === "saving" ? "var(--accent-blue)" :
                         "var(--accent-red)",
                }}>
                  {settingsSaveStatus === "saving" ? "Saving..." : settingsSaveStatus === "saved" ? "Saved ✓" : "Save error"}
                </span>
              )}
              <span className="goals-toggle-arrow" style={{ transform: goalsOpen ? "rotate(180deg)" : "rotate(0)" }}>▼</span>
            </div>
            {goalsOpen && (
              <div className="goals-grid">
                <div className="goal-field">
                  <label>Monthly Income Target ($)</label>
                  <input type="number" value={goals.monthlyTarget} min={100} step={100}
                    onChange={(e) => setGoals({ ...goals, monthlyTarget: Number(e.target.value) || 0 })} />
                </div>
                <div className="goal-field">
                  <label>Max Risk Per Trade (%)</label>
                  <input type="number" value={goals.maxRiskPct} min={0.5} max={10} step={0.5}
                    onChange={(e) => setGoals({ ...goals, maxRiskPct: Number(e.target.value) || 2 })} />
                </div>
                <div className="goal-field">
                  <label>Min Days to Expiration</label>
                  <input type="number" value={goals.minDTE} min={1} max={365} step={1}
                    onChange={(e) => setGoals({ ...goals, minDTE: Number(e.target.value) || 14 })} />
                </div>
                <div className="goal-field">
                  <label>Max Days to Expiration</label>
                  <input type="number" value={goals.maxDTE} min={1} max={365} step={1}
                    onChange={(e) => setGoals({ ...goals, maxDTE: Number(e.target.value) || 60 })} />
                </div>
                <div className="goal-field" style={{ gridColumn: "1 / -1" }}>
                  <label>Allowed Strategy Types</label>
                  <div className="goal-strat-chips">
                    {[
                      { id: "bull_call_spread", label: "Bull Call Spread" },
                      { id: "bear_put_spread", label: "Bear Put Spread" },
                      { id: "iron_condor", label: "Iron Condor" },
                      { id: "cash_secured_put", label: "Cash Secured Put" },
                      { id: "covered_call", label: "Covered Call" },
                      { id: "protective_put", label: "Protective Put" },
                      { id: "straddle", label: "Straddle" },
                      { id: "strangle", label: "Strangle" },
                    ].map((st) => (
                      <button key={st.id}
                        className={`goal-chip ${goals.strategies.includes(st.id) ? "active" : ""}`}
                        onClick={() => {
                          const has = goals.strategies.includes(st.id);
                          if (has && goals.strategies.length <= 1) return;
                          setGoals({
                            ...goals,
                            strategies: has
                              ? goals.strategies.filter((s) => s !== st.id)
                              : [...goals.strategies, st.id],
                          });
                        }}>
                        {st.label}
                      </button>
                    ))}
                  </div>
                </div>
                <div className="goal-field" style={{ gridColumn: "1 / -1" }}>
                  <label>Symbols Watchlist ({goals.symbols.length} tickers)</label>
                  <div className="watchlist-chips">
                    {goals.symbols.map((sym) => (
                      <span key={sym} className="watchlist-chip">
                        {sym}
                        <button className="watchlist-chip-remove"
                          onClick={() => setGoals({
                            ...goals,
                            symbols: goals.symbols.filter((s) => s !== sym),
                          })}>×</button>
                      </span>
                    ))}
                  </div>
                  <div className="watchlist-add-row">
                    <input className="watchlist-add-input"
                      placeholder="NVDA"
                      value={newWatchlistSymbol}
                      onChange={(e) => setNewWatchlistSymbol(e.target.value.toUpperCase())}
                      onKeyDown={(e) => {
                        if (e.key === "Enter" && newWatchlistSymbol.trim()) {
                          const sym = newWatchlistSymbol.trim();
                          if (!goals.symbols.includes(sym)) {
                            setGoals({ ...goals, symbols: [...goals.symbols, sym] });
                          }
                          setNewWatchlistSymbol("");
                        }
                      }} />
                    <button className="watchlist-add-btn"
                      onClick={() => {
                        const sym = newWatchlistSymbol.trim();
                        if (sym && !goals.symbols.includes(sym)) {
                          setGoals({ ...goals, symbols: [...goals.symbols, sym] });
                        }
                        setNewWatchlistSymbol("");
                      }}>+ Add</button>
                  </div>
                </div>
              </div>
            )}
          </div>

          {/* Goal progress summary (shown after analysis) */}
          {recommendations?.strategies?.length > 0 && (() => {
            const netLiq = recommendations?.account?.netLiquidation || acct.netLiquidation || 50000;
            const bestStrat = strategies[0];
            const avgProfit = bestStrat
              ? (bestStrat.maxProfit === "unlimited" ? bestStrat.maxLoss * 1.5 : (bestStrat.maxProfit * 0.6))
              : 0;
            const maxPerMonth = netLiq * (goals.maxRiskPct / 100);
            const tradesPerMonth = avgProfit > 0 ? Math.ceil(goals.monthlyTarget / avgProfit) : 0;
            const projectedMonthly = avgProfit * Math.min(tradesPerMonth, 12);
            const progressPct = Math.min((projectedMonthly / goals.monthlyTarget) * 100, 100);

            return (
              <div className="goal-summary">
                <div className="goal-summary-item">
                  <span className="goal-summary-label">Monthly Target</span>
                  <span className="goal-summary-value" style={{ color: "var(--accent-purple)" }}>
                    ${goals.monthlyTarget.toLocaleString()}
                  </span>
                </div>
                <div className="goal-summary-item">
                  <span className="goal-summary-label">Est. Profit/Trade</span>
                  <span className="goal-summary-value" style={{ color: "var(--accent-green)" }}>
                    {fmt.usd(avgProfit)}
                  </span>
                </div>
                <div className="goal-summary-item">
                  <span className="goal-summary-label">Trades Needed/Mo</span>
                  <span className="goal-summary-value" style={{ color: "var(--accent-cyan)" }}>
                    {tradesPerMonth > 0 ? tradesPerMonth : "—"}
                  </span>
                </div>
                <div className="goal-summary-item">
                  <span className="goal-summary-label">Max Capital/Trade</span>
                  <span className="goal-summary-value" style={{ color: "var(--accent-amber)" }}>
                    {fmt.usd(maxPerMonth)}
                  </span>
                </div>
                <div className="goal-summary-item" style={{ flex: 1, minWidth: 150 }}>
                  <span className="goal-summary-label">
                    Projected Monthly: {fmt.usd(projectedMonthly)} ({progressPct.toFixed(0)}% of goal)
                  </span>
                  <div className="goal-progress-bar">
                    <div className="goal-progress-fill" style={{
                      width: progressPct + "%",
                      background: progressPct >= 100
                        ? "var(--accent-green)"
                        : progressPct >= 50
                        ? "linear-gradient(90deg, var(--accent-purple), var(--accent-cyan))"
                        : "var(--accent-amber)",
                    }} />
                  </div>
                </div>
              </div>
            );
          })()}

          {/* Scan All button */}
          <div style={{ display: "flex", gap: 12, alignItems: "center", marginBottom: 16 }}>
            <button className="btn-scan-all" onClick={scanAll} disabled={scanningAll || goals.symbols.length === 0}>
              {scanningAll ? (
                <><div className="spinner" style={{ width: 16, height: 16, borderWidth: 2, marginBottom: 0 }} /> Scanning {goals.symbols.length} symbols...</>
              ) : (
                <>🔍 Scan All & Build Plan ({goals.symbols.length} symbols)</>
              )}
            </button>
            <span style={{ fontSize: 11, color: "var(--text-muted)" }}>
              Analyzes all watchlist symbols and builds an optimal combination to reach your monthly target
            </span>
          </div>

          {/* ── Portfolio Plan (multi-symbol combined) ────── */}
          {portfolioPlan && (
            <div className="plan-container">
              <div className="plan-header">
                <div className="plan-title">
                  <span style={{ fontSize: 20 }}>📊</span>
                  Portfolio Plan — Path to {fmt.usd(portfolioPlan.monthlyTarget)}/mo
                </div>
                <div className="plan-target-badge">
                  {portfolioPlan.progressPct >= 100 ? "✓ Goal Achievable" : `${portfolioPlan.progressPct.toFixed(0)}% of Goal`}
                </div>
              </div>

              {/* Summary stats */}
              <div className="plan-summary-row">
                <div className="plan-summary-item">
                  <div className="plan-summary-value" style={{ color: "var(--accent-purple)" }}>
                    {fmt.usd(portfolioPlan.monthlyTarget)}
                  </div>
                  <div className="plan-summary-label">Monthly Target</div>
                </div>
                <div className="plan-summary-item">
                  <div className="plan-summary-value" style={{ color: "var(--accent-green)" }}>
                    {fmt.usd(portfolioPlan.projectedMonthly)}
                  </div>
                  <div className="plan-summary-label">Projected Monthly</div>
                </div>
                <div className="plan-summary-item">
                  <div className="plan-summary-value" style={{ color: "var(--accent-cyan)" }}>
                    {portfolioPlan.selectedStrategies.length}
                  </div>
                  <div className="plan-summary-label">Active Trades</div>
                </div>
                <div className="plan-summary-item">
                  <div className="plan-summary-value" style={{ color: "var(--accent-amber)" }}>
                    {fmt.usd(portfolioPlan.totalCapitalRequired)}
                  </div>
                  <div className="plan-summary-label">Total Capital</div>
                </div>
                <div className="plan-summary-item">
                  <div className="plan-summary-value" style={{
                    color: portfolioPlan.totalRiskPct > 5 ? "var(--accent-red)" : "var(--accent-green)"
                  }}>
                    {portfolioPlan.totalRiskPct.toFixed(1)}%
                  </div>
                  <div className="plan-summary-label">Total Risk</div>
                </div>
              </div>

              {/* Progress bar */}
              <div className="plan-progress-section">
                <div className="plan-progress-header">
                  <span style={{ fontWeight: 700 }}>Goal Progress</span>
                  <span style={{
                    fontWeight: 700,
                    color: portfolioPlan.progressPct >= 100 ? "var(--accent-green)" : "var(--accent-purple)",
                  }}>
                    {fmt.usd(portfolioPlan.projectedMonthly)} / {fmt.usd(portfolioPlan.monthlyTarget)}
                  </span>
                </div>
                <div className="plan-progress-bar">
                  <div className="plan-progress-fill" style={{
                    width: Math.min(portfolioPlan.progressPct, 100) + "%",
                    background: portfolioPlan.progressPct >= 100
                      ? "linear-gradient(90deg, var(--accent-green), #34d399)"
                      : portfolioPlan.progressPct >= 60
                      ? "linear-gradient(90deg, var(--accent-purple), var(--accent-cyan))"
                      : "linear-gradient(90deg, var(--accent-amber), var(--accent-red))",
                  }} />
                </div>
              </div>

              {/* Per-symbol breakdown */}
              {(() => {
                // Group strategies by symbol
                const bySymbol = {};
                (portfolioPlan.selectedStrategies || []).forEach((s, i) => {
                  if (!bySymbol[s.symbol]) bySymbol[s.symbol] = [];
                  bySymbol[s.symbol].push({ ...s, idx: i });
                });
                return Object.entries(bySymbol).map(([sym, strats]) => {
                  const symProfit = strats.reduce((sum, s) => sum + s.expectedProfit, 0);
                  return (
                    <div key={sym} className="plan-symbol-section">
                      <div className="plan-symbol-header">
                        <span>{sym} — {strats.length} {strats.length === 1 ? "strategy" : "strategies"}</span>
                        <span style={{ color: "var(--accent-green)", fontWeight: 700 }}>
                          +{fmt.usd(symProfit)}/trade
                        </span>
                      </div>
                      <div className="plan-strategies-list">
                        {strats.map((s) => {
                          const allocationPct = portfolioPlan.totalCapitalRequired > 0
                            ? (s.capitalRequired / portfolioPlan.totalCapitalRequired * 100)
                            : 0;
                          const isExpanded = expandedPlanIdx === s.idx;
                          const showManual = planManualIdx === s.idx;
                          return (
                            <div key={s.idx}>
                              <div className="plan-strat-row"
                                style={{ cursor: "pointer", borderColor: isExpanded ? "rgba(139,92,246,0.5)" : undefined, background: isExpanded ? "rgba(139,92,246,0.04)" : undefined }}
                                onClick={() => setExpandedPlanIdx(isExpanded ? null : s.idx)}>
                                <div className="plan-strat-num">{s.idx + 1}</div>
                                <div>
                                  <div className="plan-strat-name">
                                    {s.name}
                                    <span style={{ marginLeft: 6, fontSize: 10, color: "var(--text-muted)" }}>
                                      {isExpanded ? "▲" : "▼"}
                                    </span>
                                  </div>
                                  <div className="plan-strat-symbol">{s.type}</div>
                                </div>
                                <div className="plan-strat-profit">+{fmt.usd(s.expectedProfit)}</div>
                                <div className="plan-strat-risk" style={{
                                  color: s.riskPct > 2 ? "var(--accent-red)" : "var(--accent-green)"
                                }}>
                                  Risk: {s.riskPct.toFixed(1)}%
                                </div>
                                <div className="plan-strat-capital">{fmt.usd(s.capitalRequired)}</div>
                                <div className="plan-strat-dte">{s.avgDTE}d DTE</div>
                                <div className="plan-strat-pct" style={{
                                  background: "rgba(139,92,246,0.1)",
                                  color: "var(--accent-purple)",
                                }}>
                                  {allocationPct.toFixed(0)}%
                                </div>
                              </div>

                              {/* ── Expanded detail panel ──── */}
                              {isExpanded && (
                                <div style={{
                                  background: "rgba(139,92,246,0.03)",
                                  border: "1px solid rgba(139,92,246,0.2)",
                                  borderTop: "none",
                                  borderRadius: "0 0 10px 10px",
                                  padding: 16,
                                  marginTop: -1,
                                }}>
                                  {/* Strategy details grid */}
                                  <div className="strategy-details" style={{ marginBottom: 12 }}>
                                    <div>
                                      <div className="strategy-detail-label">Max Profit</div>
                                      <div className="strategy-detail-value positive">
                                        {s.maxProfit === "unlimited" ? "Unlimited" : fmt.usd(s.maxProfit)}
                                      </div>
                                    </div>
                                    <div>
                                      <div className="strategy-detail-label">Max Loss</div>
                                      <div className="strategy-detail-value negative">{fmt.usd(s.maxLoss)}</div>
                                    </div>
                                    <div>
                                      <div className="strategy-detail-label">Capital Required</div>
                                      <div className="strategy-detail-value">{fmt.usd(s.capitalRequired)}</div>
                                    </div>
                                    <div>
                                      <div className="strategy-detail-label">Score</div>
                                      <div className="strategy-detail-value" style={{ color: "var(--accent-blue)" }}>{s.score.toFixed(0)}</div>
                                    </div>
                                  </div>

                                  {/* Legs badges */}
                                  <div className="legs" style={{ marginBottom: 12 }}>
                                    {(s.legs || []).map((leg, li) => (
                                      <div key={li} className={`leg-badge ${leg.side === "buy" ? "leg-buy" : "leg-sell"}`}>
                                        {leg.side.toUpperCase()} {leg.quantity}x {leg.type.toUpperCase()} ${leg.strike}
                                        {leg.expiration && (() => {
                                          const d = parseExpDate(leg.expiration);
                                          return !isNaN(d.getTime()) ? (
                                            <span style={{ marginLeft: 4, opacity: 0.7, fontSize: 10 }}>
                                              {d.toLocaleDateString("en-US", { month: "short", day: "numeric" })}
                                            </span>
                                          ) : null;
                                        })()}
                                      </div>
                                    ))}
                                  </div>

                                  {/* Factor bars */}
                                  {s.factors?.length > 0 && (
                                    <div style={{ marginBottom: 12 }}>
                                      <div className="card-title">SHAP Factor Attribution</div>
                                      <FactorBars factors={s.factors} />
                                    </div>
                                  )}

                                  {/* Action buttons */}
                                  <div style={{ display: "flex", gap: 10, alignItems: "center" }}>
                                    <button
                                      className="btn-approve"
                                      onClick={(e) => {
                                        e.stopPropagation();
                                        // Find this strategy in cached recommendations by loading it first
                                        // For now, set symbol and trigger single analysis
                                        setSymbol(s.symbol);
                                        addToast("info", "Analyze First",
                                          `Run single-symbol analysis on ${s.symbol} to approve via IBKR. Use Manual Entry for direct TWS placement.`);
                                      }}
                                    >
                                      ⚡ Analyze {s.symbol} to Approve
                                    </button>
                                    <button
                                      className="btn-manual"
                                      onClick={(e) => {
                                        e.stopPropagation();
                                        setPlanManualIdx(showManual ? null : s.idx);
                                      }}
                                    >
                                      {showManual ? "Hide Manual Details" : "📋 Manual Entry"}
                                    </button>
                                  </div>

                                  {!showManual && (
                                    <div className="risk-warning" style={{ marginTop: 10 }}>
                                      <b>📋 Manual Entry</b> — shows all contract details to enter in IBKR TWS manually.
                                      <br/>
                                      <b>⚡ Analyze</b> — runs full analysis on {s.symbol} to enable automatic IBKR submission.
                                    </div>
                                  )}

                                  {/* Manual entry panel */}
                                  {showManual && (
                                    <div style={{ marginTop: 12 }}>
                                      <ManualLegPanel legs={s.legs} strategyName={s.name} />
                                    </div>
                                  )}
                                </div>
                              )}
                            </div>
                          );
                        })}
                      </div>
                    </div>
                  );
                });
              })()}

              {/* Allocation chart */}
              {portfolioPlan.selectedStrategies?.length > 0 && (
                <div style={{ marginTop: 16, padding: 12, background: "rgba(0,0,0,0.1)", borderRadius: 10 }}>
                  <div style={{ fontSize: 11, color: "var(--text-muted)", textTransform: "uppercase", letterSpacing: 1, marginBottom: 8 }}>
                    Capital Allocation
                  </div>
                  <div style={{ display: "flex", borderRadius: 6, overflow: "hidden", height: 24 }}>
                    {portfolioPlan.selectedStrategies.map((s, i) => {
                      const pct = portfolioPlan.totalCapitalRequired > 0
                        ? (s.capitalRequired / portfolioPlan.totalCapitalRequired * 100)
                        : 0;
                      const colors = ["var(--accent-blue)", "var(--accent-green)", "var(--accent-purple)",
                        "var(--accent-cyan)", "var(--accent-amber)", "var(--accent-red)"];
                      return (
                        <div key={i} style={{
                          width: pct + "%",
                          background: colors[i % colors.length],
                          display: "flex", alignItems: "center", justifyContent: "center",
                          fontSize: 9, fontWeight: 700, color: "white",
                          minWidth: pct > 5 ? 0 : 2,
                        }} title={`${s.symbol} ${s.name}: ${pct.toFixed(0)}%`}>
                          {pct > 8 ? s.symbol : ""}
                        </div>
                      );
                    })}
                  </div>
                  <div style={{ display: "flex", gap: 12, marginTop: 8, flexWrap: "wrap" }}>
                    {portfolioPlan.selectedStrategies.map((s, i) => {
                      const colors = ["var(--accent-blue)", "var(--accent-green)", "var(--accent-purple)",
                        "var(--accent-cyan)", "var(--accent-amber)", "var(--accent-red)"];
                      return (
                        <div key={i} style={{ display: "flex", alignItems: "center", gap: 4, fontSize: 10 }}>
                          <div style={{ width: 8, height: 8, borderRadius: 2, background: colors[i % colors.length] }} />
                          <span style={{ color: "var(--text-muted)" }}>{s.symbol}</span>
                          <span style={{ fontWeight: 600 }}>{s.name}</span>
                        </div>
                      );
                    })}
                  </div>
                </div>
              )}

              {portfolioPlan.selectedStrategies?.length === 0 && (
                <div style={{ textAlign: "center", padding: 30, color: "var(--text-muted)" }}>
                  No strategies found matching your goal criteria. Try adjusting risk %, DTE range, or adding more symbols.
                </div>
              )}
            </div>
          )}

          <div style={{ display: "flex", gap: 12, alignItems: "center", marginBottom: 4 }}>
            <span style={{ fontSize: 11, color: "var(--text-muted)", textTransform: "uppercase", letterSpacing: 1 }}>
              Or analyze a single symbol:
            </span>
          </div>
          <div className="symbol-input-group">
            <input className="symbol-input" placeholder="AAPL" value={symbol}
              onChange={(e) => setSymbol(e.target.value.toUpperCase())}
              onKeyDown={(e) => e.key === "Enter" && analyze()} />
            <button className="btn-analyze" onClick={analyze} disabled={analyzing}>
              {analyzing ? "Analyzing..." : "Analyze"}
            </button>
          </div>

          {/* ── Data Source Banner — prominent, always visible ── */}
          {recommendations?.market && (() => {
            const ds = recommendations.market.dataSource;
            const isIBKR = ds === "ibkr" || ds === "ibkr-delayed";
            const isLive = ds === "ibkr";
            const isDelayed = ds === "ibkr-delayed";
            const isYahoo = ds === "yahoo";
            const bannerColor = isLive ? "#10b981" : isDelayed ? "#f59e0b" : isYahoo ? "#3b82f6" : "#ef4444";
            const bannerBg = isLive ? "rgba(16,185,129,0.1)" : isDelayed ? "rgba(245,158,11,0.1)" : isYahoo ? "rgba(59,130,246,0.1)" : "rgba(239,68,68,0.1)";
            const sourceLabel = isLive ? "IBKR REAL-TIME" : isDelayed ? "IBKR DELAYED (15min)" : isYahoo ? "YAHOO FINANCE" : ds === "portfolio" ? "IBKR PORTFOLIO" : "UNKNOWN SOURCE";
            const sourceIcon = isLive ? "🟢" : isDelayed ? "🟡" : isYahoo ? "🔵" : "🔴";
            return (
              <div style={{ background: bannerBg, border: `1px solid ${bannerColor}`, borderRadius: 8, padding: "10px 16px", marginBottom: 12, display: "flex", alignItems: "center", gap: 16, flexWrap: "wrap" }}>
                <div style={{ display: "flex", alignItems: "center", gap: 8 }}>
                  <span style={{ fontSize: 16 }}>{sourceIcon}</span>
                  <span style={{ color: bannerColor, fontWeight: 700, fontSize: 12, letterSpacing: 1 }}>{sourceLabel}</span>
                </div>
                <div style={{ display: "flex", alignItems: "baseline", gap: 6 }}>
                  <span style={{ color: "var(--text-muted)", fontSize: 11 }}>{symbol}:</span>
                  <span style={{ color: "var(--text-primary)", fontWeight: 700, fontSize: 20 }}>${recommendations.market.price.toFixed(2)}</span>
                </div>
                <div style={{ display: "flex", gap: 16, fontSize: 11 }}>
                  <span style={{ color: "var(--text-muted)" }}>IV Rank: <b style={{ color: "var(--accent-purple)" }}>{recommendations.market.ivRank}</b></span>
                  <span style={{ color: "var(--text-muted)" }}>HV30: <b style={{ color: "var(--accent-amber)" }}>{(recommendations.market.hv30 * 100).toFixed(1)}%</b></span>
                </div>
                <div style={{ marginLeft: "auto", display: "flex", gap: 16, fontSize: 11 }}>
                  <span style={{ color: "var(--text-muted)" }}>Available: <b style={{ color: "var(--accent-green)" }}>{fmt.usd(recommendations?.account?.availableFunds || acct.availableFunds)}</b></span>
                  <span style={{ color: "var(--text-muted)" }}>Tier: <b style={{ color: "var(--accent-purple)", textTransform: "uppercase" }}>{recommendations?.account?.tier || acct.tier || "medium"}</b></span>
                </div>
              </div>
            );
          })()}

          {/* ── Market Analysis Panel — technical indicators ── */}
          {recommendations?.market?.technical && (
            <MarketAnalysisPanel technical={recommendations.market.technical} price={recommendations.market.price} />
          )}

          {/* Account bar — when no analysis yet */}
          {!recommendations?.market && (
            <div className="analysis-account-bar">
              <div className="analysis-account-item">
                <div className="analysis-account-dot" style={{ background: "var(--accent-green)" }} />
                <span style={{ color: "var(--text-muted)" }}>Available:</span>
                <strong style={{ color: "var(--accent-green)" }}>{fmt.usd(acct.availableFunds)}</strong>
              </div>
              <div className="analysis-account-item">
                <div className="analysis-account-dot" style={{ background: "var(--accent-purple)" }} />
                <span style={{ color: "var(--text-muted)" }}>Tier:</span>
                <strong style={{ color: "var(--accent-purple)", textTransform: "uppercase" }}>
                  {acct.tier || "medium"}
                </strong>
              </div>
            </div>
          )}

          {analyzing && (
            <div className="loading">
              <div className="spinner" />
              <div>Running quant analysis on {symbol}...</div>
            </div>
          )}

          {strategies.length > 0 && (
            <div className="main-grid">
              <div>
                <div className="card-title" style={{ marginBottom: 12 }}>
                  Recommended Strategies ({strategies.length})
                </div>
                {strategies.map((s, i) => (
                  <StrategyCard key={i} strategy={s} index={i}
                    selected={selectedStrategy === i}
                    onSelect={setSelectedStrategy}
                    onApprove={approveStrategy} />
                ))}
              </div>
              <div>
                <div className="card" style={{ marginBottom: 16 }}>
                  <div className="card-title">Payoff at Expiration</div>
                  <PayoffChart strategies={strategies} selectedIdx={selectedStrategy} market={recommendations?.market} />
                </div>
                {strategies[selectedStrategy]?.factors?.length > 0 && (
                  <div className="card">
                    <div className="card-title">XAI — Factor Attribution</div>
                    <FactorBars factors={strategies[selectedStrategy].factors} />
                  </div>
                )}
              </div>
            </div>
          )}
        </div>
      )}

      {/* ── Option Chain Tab ─────────────────────────── */}
      {activeTab === "chain" && (
        <OptionChainTab positions={positions} />
      )}

      {/* ── Orders Tab ─────────────────────────────── */}
      {activeTab === "orders" && (
        <OrdersTab orders={orders} />
      )}

      {/* ── Risk Tab ──────────────────────────────── */}
      {activeTab === "risk" && (
        <div className="main-grid">
          <div className="card">
            <div className="card-title">Value at Risk (95% Confidence)</div>
            <div style={{ marginBottom: 20 }}>
              <div style={{ display: "grid", gridTemplateColumns: "1fr 1fr", gap: 16, marginBottom: 20 }}>
                <div>
                  <div className="metric-label">1-Day VaR</div>
                  <div className="metric-value negative" style={{ fontSize: 28 }}>
                    {fmt.usd(varData?.var || portfolio?.var?.var || 0)}
                  </div>
                </div>
                <div>
                  <div className="metric-label">CVaR (Expected Shortfall)</div>
                  <div className="metric-value" style={{ fontSize: 28, color: "var(--accent-amber)" }}>
                    {fmt.usd(varData?.cvar || portfolio?.var?.cvar || 0)}
                  </div>
                </div>
              </div>
              <div className="metric-label">
                Method: {(varData?.method || portfolio?.var?.method || "historical").toUpperCase()} |
                Horizon: {varData?.horizon || 1} day |
                Confidence: {((varData?.confidenceLevel || 0.95) * 100).toFixed(0)}%
              </div>
            </div>
          </div>
          <div className="card">
            <div className="card-title">Stress Tests (±15% Move)</div>
            <StressTestChart stressTests={varData?.stressTests || portfolio?.var?.stressTests || []} />
          </div>
          <div className="card full-width">
            <div className="card-title">Risk Limits</div>
            <div style={{ display: "grid", gridTemplateColumns: "repeat(4, 1fr)", gap: 20, fontSize: 13 }}>
              <div>
                <div className="metric-label">Max Risk / Trade</div>
                <div style={{ fontSize: 20, fontWeight: 700, color: "var(--accent-amber)" }}>2%</div>
              </div>
              <div>
                <div className="metric-label">Max Position Size</div>
                <div style={{ fontSize: 20, fontWeight: 700 }}>10%</div>
              </div>
              <div>
                <div className="metric-label">Portfolio VaR Limit</div>
                <div style={{ fontSize: 20, fontWeight: 700 }}>5%</div>
              </div>
              <div>
                <div className="metric-label">Account Tier</div>
                <div style={{ fontSize: 20, fontWeight: 700, color: "var(--accent-blue)", textTransform: "uppercase" }}>
                  {acct.tier || "medium"}
                </div>
              </div>
            </div>
          </div>
        </div>
      )}

      {/* Footer */}
      <div style={{ textAlign: "center", padding: "30px 0 10px", color: "var(--text-muted)", fontSize: 11 }}>
        Click System v1.0 — API-First IBKR Integration — Human-in-the-Loop Required for All Trades
      </div>
    </div>
  );
}

ReactDOM.createRoot(document.getElementById("root")).render(<App />);
</script>
</body>
</html>
